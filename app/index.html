<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Steno Recorder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Header with record controls */
        .header {
            background: #111;
            border-bottom: 1px solid #333;
            padding: 36px 24px 16px 16px; /* More top padding, move content left */
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: padding-top 0.3s ease;
        }
        
        .header.with-update-banner {
            padding-top: 84px; /* Additional space when update banner is shown */
        }
        
        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .brand h1 {
            font-size: 20px;
            font-weight: 600;
            color: #fff;
        }
        
        .header-actions {
            display: flex;
            align-items: center;
        }
        
        .settings-btn {
            background: transparent;
            border: 1px solid #444;
            color: #ccc;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .settings-btn:hover {
            background: #333;
            border-color: #555;
            color: #fff;
        }
        
        .record-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .session-input {
            background: #222;
            border: 1px solid #444;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            min-width: 200px;
            outline: none;
        }
        
        .session-input:focus {
            border-color: #666;
            background: #333;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 16px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        
        .status-dot.ready { background: #22c55e; }
        .status-dot.recording { 
            background: #ef4444; 
            animation: pulse 1s infinite;
        }
        .status-dot.processing { 
            background: #f59e0b; 
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn:hover {
            background: #444;
            border-color: #666;
        }
        
        .btn-primary {
            background: #fff;
            color: #000;
            border-color: #fff;
        }
        
        .btn-primary:hover {
            background: #f5f5f5;
        }
        
        .btn-danger {
            background: #ef4444;
            border-color: #ef4444;
        }
        
        .btn-danger:hover {
            background: #dc2626;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: #111;
            border-left: 1px solid #333;
            transition: right 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        
        .settings-header {
            padding: 20px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .settings-header h2 {
            margin: 0;
            font-size: 18px;
            color: #fff;
        }
        
        .close-settings {
            background: none;
            border: none;
            color: #ccc;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .close-settings:hover {
            background: #333;
            color: #fff;
        }
        
        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .settings-section {
            margin-bottom: 32px;
        }
        
        .settings-section h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #fff;
        }
        
        .settings-section h4 {
            margin: 16px 0 8px 0;
            font-size: 14px;
            color: #ccc;
        }
        
        .settings-section p {
            margin: 0 0 16px 0;
            color: #aaa;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .setup-info ul {
            margin: 16px 0;
            padding-left: 20px;
            color: #ccc;
        }
        
        .setup-info li {
            margin-bottom: 4px;
            font-size: 14px;
        }
        
        .prompt-viewer {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 16px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre-wrap;
            color: #ccc;
            max-height: 300px;
            overflow-y: auto;
        }
        
        /* Debug Panel */
        .debug-panel {
            position: fixed;
            top: 0;
            right: -500px;
            width: 500px;
            height: 100vh;
            background: #0a0a0a;
            border-left: 1px solid #333;
            transition: right 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        
        .debug-header {
            padding: 20px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #111;
        }
        
        .debug-header h2 {
            margin: 0;
            font-size: 18px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .debug-console {
            flex: 1;
            background: #000;
            color: #a0a0a0;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 11px;
            line-height: 1.4;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .debug-console::-webkit-scrollbar {
            width: 8px;
        }
        
        .debug-console::-webkit-scrollbar-track {
            background: #111;
        }
        
        .debug-console::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        
        .debug-console::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Main content area */
        .main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        /* Sidebar with meetings list */
        .sidebar {
            width: 320px;
            background: #111;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #333;
        }
        
        .sidebar-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .sidebar-header h2 {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
        }
        
        
        .search-input {
            background: #222;
            border: 1px solid #444;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            width: 100%;
            outline: none;
            margin: 12px 0 8px 0;
        }
        
        .search-input:focus {
            border-color: #666;
            background: #333;
        }
        
        .sidebar-header p {
            font-size: 14px;
            color: #888;
        }
        
        .meetings-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }
        
        .meeting-item {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .meeting-delete {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #444;
            border: none;
            color: #999;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
        }
        
        .meeting-item:hover .meeting-delete {
            opacity: 1;
        }
        
        .meeting-delete:hover {
            background: #ef4444;
            color: #fff;
        }
        
        .meeting-item:hover {
            background: #222;
            border-color: #444;
        }
        
        .meeting-item.active {
            background: #333;
            border-color: #555;
        }
        
        .meeting-item.processing {
            background: #1a1a1a;
            border-color: #f59e0b;
            opacity: 0.7;
            position: relative;
        }
        
        .meeting-item.processing .processing-overlay {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 4px;
            padding: 4px 8px;
        }
        
        .processing-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #f59e0b;
            font-size: 12px;
            font-weight: 500;
        }
        
        .processing-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #333;
            border-top: 2px solid #f59e0b;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .meeting-item h3 {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 6px;
            line-height: 1.3;
        }
        
        .meeting-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .meeting-date {
            font-size: 12px;
            color: #888;
        }
        
        .meeting-duration {
            font-size: 12px;
            color: #666;
            background: #222;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .meeting-preview {
            font-size: 13px;
            color: #aaa;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        /* Main content area */
        .content {
            flex: 1;
            background: #000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .content-empty {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            flex-direction: column;
            color: #666;
        }
        
        .content-empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        .content-empty h3 {
            font-size: 18px;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .content-empty p {
            font-size: 14px;
            color: #888;
        }
        
        /* Meeting detail view */
        .meeting-detail {
            padding: 32px;
            height: 100%;
            overflow-y: auto;
            display: none;
        }
        
        .meeting-detail.show {
            display: block;
        }
        
        .meeting-header {
            margin-bottom: 32px;
            padding-bottom: 24px;
            border-bottom: 1px solid #333;
        }
        
        .meeting-header-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }
        
        .meeting-title {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            margin: 0;
            flex: 1;
        }
        
        .reprocess-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 16px;
            flex-shrink: 0;
        }
        
        .reprocess-btn:hover {
            background: #444;
        }
        
        .reprocess-btn:active {
            transform: translateY(0);
        }
        
        .reprocess-btn:disabled {
            background: #333;
            color: #999;
            border-color: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        .reprocess-btn.processing {
            background: #FF9800;
            color: #fff;
            border-color: #FF9800;
        }
        
        .reprocess-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .transcript-container {
            position: relative;
        }
        
        .copy-transcript-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 6px;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-transcript-btn:hover {
            background: #444;
            opacity: 1;
            transform: translateY(-1px);
        }
        
        .copy-transcript-btn:active {
            transform: translateY(0);
        }
        
        .copy-transcript-btn.copied {
            background: #4CAF50;
            border-color: #4CAF50;
            opacity: 1;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .meeting-info {
            display: flex;
            gap: 24px;
            align-items: center;
            color: #888;
            font-size: 14px;
        }
        
        .meeting-section {
            margin-bottom: 32px;
        }
        
        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section-content {
            color: #ccc;
            line-height: 1.6;
        }
        
        .key-points-list {
            list-style: none;
            padding: 0;
        }
        
        .key-points-list li {
            padding: 8px 0;
            padding-left: 20px;
            position: relative;
            color: #ccc;
            line-height: 1.5;
        }
        
        .key-points-list li:before {
            content: "•";
            position: absolute;
            left: 0;
            color: #666;
            font-weight: bold;
        }
        
        .action-items-list {
            list-style: none;
            padding: 0;
        }
        
        .action-items-list li {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            color: #ccc;
            line-height: 1.5;
        }
        
        /* Transcript section */
        .transcript-content {
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #ddd;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        
        /* File drop area */
        .drop-zone {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .drop-zone.active {
            display: flex;
        }
        
        .drop-message {
            text-align: center;
            color: #fff;
            font-size: 24px;
            font-weight: 600;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #111;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }
        
        /* Update Banner */
        .update-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #4F46E5, #7C3AED);
            color: white;
            padding: 12px 20px;
            display: none;
            align-items: center;
            justify-content: space-between;
            z-index: 1500;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .update-banner.show {
            display: flex;
        }
        
        .update-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .update-icon {
            font-size: 20px;
            animation: pulse 2s infinite;
        }
        
        .update-text {
            font-size: 14px;
        }
        
        .update-text .version {
            font-weight: 600;
        }
        
        .update-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .update-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .update-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .update-btn.primary {
            background: white;
            color: #4F46E5;
            font-weight: 600;
        }
        
        .update-btn.primary:hover {
            background: #f3f4f6;
        }
        
        .dismiss-update {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            border-radius: 2px;
            transition: color 0.2s;
        }
        
        .dismiss-update:hover {
            color: white;
        }

        /* Setup Modal */
        .setup-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .setup-content {
            background: #111;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 32px;
            width: 600px;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .setup-header {
            text-align: center;
            margin-bottom: 32px;
        }
        
        .setup-header .btn-primary {
            margin-top: 20px;
            font-size: 16px;
            padding: 12px 24px;
        }
        
        .setup-header h2 {
            font-size: 24px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
        }
        
        .setup-header p {
            font-size: 16px;
            color: #888;
        }
        
        .setup-steps {
            margin-bottom: 32px;
        }
        
        .setup-step {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px;
            margin-bottom: 12px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .setup-step.active {
            border-color: #555;
            background: #222;
        }
        
        .setup-step.completed {
            border-color: #22c55e;
            background: #0f1f0f;
        }
        
        .setup-step.failed {
            border-color: #ef4444;
            background: #1f0f0f;
        }
        
        .step-icon {
            font-size: 24px;
            width: 40px;
            text-align: center;
        }
        
        .step-content {
            flex: 1;
        }
        
        .step-content h3 {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .step-content p {
            font-size: 14px;
            color: #888;
            margin-bottom: 8px;
        }
        
        .step-status {
            font-size: 13px;
            color: #666;
            font-weight: 500;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #f59e0b;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        
        .setup-step.completed .progress-fill {
            background: #22c55e;
            width: 100%;
        }
        
        .setup-step.active .step-status {
            color: #f59e0b;
        }
        
        .setup-step.completed .step-status {
            color: #22c55e;
        }
        
        .setup-step.failed .step-status {
            color: #ef4444;
        }
        
        .setup-actions {
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }
        
        .setup-actions .btn {
            flex: 1;
        }
    </style>
</head>
<body>
    <!-- Update Banner -->
    <div class="update-banner" id="update-banner">
        <div class="update-info">
            <div class="update-icon">🚀</div>
            <div class="update-text">
                <span>New version available: </span>
                <span class="version" id="update-version">v0.0.17</span>
            </div>
        </div>
        <div class="update-actions">
            <button class="update-btn" id="view-release-btn">View Release</button>
            <button class="update-btn primary" id="download-update-btn">Download Update</button>
            <button class="dismiss-update" id="dismiss-update-btn" title="Dismiss">✕</button>
        </div>
    </div>

    <!-- Header with recording controls -->
    <div class="header">
        <div class="brand">
            <svg width="28" height="28" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect width="32" height="32" rx="8" fill="#1e293b"/>
                <rect width="30" height="30" x="1" y="1" rx="7" stroke="rgba(255,255,255,0.1)"/>
                <path d="M16 10c-1.1 0-2 .9-2 2v4c0 1.1.9 2 2 2s2-.9 2-2v-4c0-1.1-.9-2-2-2z" fill="white"/>
                <path d="M12 15v1c0 2.2 1.8 4 4 4s4-1.8 4-4v-1h1v1c0 2.7-1.9 4.9-4.5 5.4v1.6h2v1h-5v-1h2v-1.6c-2.6-.5-4.5-2.7-4.5-5.4v-1h1z" fill="white"/>
            </svg>
            <h1>StenoAI</h1>
        </div>
        
        <div class="record-controls">
            <div class="status">
                <div class="status-dot ready" id="status-dot"></div>
                <span id="status-text">Ready</span>
            </div>
            
            <input type="text" class="session-input" id="session-name" placeholder="Enter meeting name..." value="Meeting">
            
            <button class="btn btn-primary" id="start-btn">
                <span>●</span> Start Recording
            </button>
            
            <button class="btn btn-danger" id="stop-btn" style="display: none;">
                <span>■</span> Stop Recording
            </button>
        </div>
        
        <div class="header-actions">
            <button class="settings-btn" id="debug-btn" title="Debug Logs" style="margin-right: 8px;">🔨</button>
            <button class="settings-btn" id="settings-btn" title="Settings">⚙️</button>
        </div>
    </div>

    <!-- Main content area -->
    <div class="main">
        <!-- Sidebar with meetings -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">
                    <h2>Meetings</h2>
                </div>
                <input type="text" class="search-input" id="search-input" placeholder="Search meetings...">
            </div>
            
            <div class="meetings-list" id="meetings-list">
                <!-- Meetings will be loaded here -->
            </div>
        </div>

        <!-- Main content -->
        <div class="content">
            <!-- Empty state -->
            <div class="content-empty" id="empty-state">
                <div class="content-empty-icon">📝</div>
                <h3>No meeting selected</h3>
                <p>Select a meeting from the sidebar or record a new one</p>
            </div>

            <!-- Meeting detail view -->
            <div class="meeting-detail" id="meeting-detail">
                <div class="meeting-header">
                    <div class="meeting-header-top">
                        <h1 class="meeting-title" id="detail-title">Meeting Title</h1>
                        <button class="reprocess-btn" id="reprocess-btn" title="Reprocess current meeting if analysis failed or needs improvement">
                            Reprocess
                        </button>
                    </div>
                    <div class="meeting-info">
                        <span id="detail-date">Date</span>
                        <span id="detail-duration">Duration</span>
                    </div>
                </div>

                <div class="meeting-section">
                    <h2 class="section-title">
                        <span>📋</span> Summary
                    </h2>
                    <div class="section-content" id="detail-summary">
                        Meeting summary will appear here...
                    </div>
                </div>

                <div class="meeting-section">
                    <h2 class="section-title">
                        <span>👥</span> Participants
                    </h2>
                    <div class="section-content" id="detail-participants">
                        <!-- Participants will be loaded here -->
                    </div>
                </div>

                <div class="meeting-section">
                    <h2 class="section-title">
                        <span>🔑</span> Key Points
                    </h2>
                    <ul class="key-points-list" id="detail-key-points">
                        <!-- Key points will be loaded here -->
                    </ul>
                </div>

                <div class="meeting-section">
                    <h2 class="section-title">
                        <span>✅</span> Action Items
                    </h2>
                    <ul class="action-items-list" id="detail-action-items">
                        <!-- Action items will be loaded here -->
                    </ul>
                </div>

                <div class="meeting-section">
                    <h2 class="section-title">
                        <span>📄</span> Full Transcript
                    </h2>
                    <div class="transcript-container">
                        <div class="transcript-content" id="detail-transcript">
                            Full transcript will appear here...
                        </div>
                        <button class="copy-transcript-btn" id="copy-transcript-btn" title="Copy transcript to clipboard">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Drop zone for files -->
    <div class="drop-zone" id="drop-zone">
        <div class="drop-message">
            Drop audio file to process
        </div>
    </div>

    <!-- Setup overlay -->
    <div class="setup-modal" id="setup-overlay" style="display: none;">
        <div class="setup-content">
            <div class="setup-header">
                <h2>🚀 Welcome to StenoAI</h2>
                <p>Setting up your system for meeting transcription...</p>
                <p style="font-size: 12px; color: #888; margin-top: 8px;">💡 Scroll down to begin setup</p>
            </div>
            
            <div class="setup-steps" id="setup-steps">
                <div class="setup-step" id="step-microphone">
                    <div class="step-icon">🎤</div>
                    <div class="step-content">
                        <h3>Microphone Access</h3>
                        <p>Grant microphone permission for meeting recording</p>
                        <div class="step-status" id="microphone-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="microphone-progress"></div>
                        </div>
                    </div>
                </div>
                
                <div class="setup-step" id="step-system">
                    <div class="step-icon">🖥️</div>
                    <div class="step-content">
                        <h3>System Check</h3>
                        <p>Checking Python and system requirements...</p>
                        <div class="step-status" id="system-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="system-progress"></div>
                        </div>
                    </div>
                </div>

                
                <div class="setup-step" id="step-python">
                    <div class="step-icon">🐍</div>
                    <div class="step-content">
                        <h3>Python Dependencies</h3>
                        <p>Installing audio libraries</p>
                        <div class="step-status" id="python-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="python-progress"></div>
                        </div>
                    </div>
                </div>
                
                <div class="setup-step" id="step-whisper">
                    <div class="step-icon">🎤</div>
                    <div class="step-content">
                        <h3>Install Whisper</h3>
                        <p>OpenAI's speech recognition engine</p>
                        <div class="step-status" id="whisper-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="whisper-progress"></div>
                        </div>
                    </div>
                </div>
                
                <div class="setup-step" id="step-ollama">
                    <div class="step-icon">🧠</div>
                    <div class="step-content">
                        <h3>Install Ollama + AI Model</h3>
                        <p>Homebrew (if needed) → Ollama → Llama 3.2 model (~2GB)</p>
                        <div class="step-status" id="ollama-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="ollama-progress"></div>
                        </div>
                    </div>
                </div>
                
                <div class="setup-step" id="step-ffmpeg">
                    <div class="step-icon">🎥</div>
                    <div class="step-content">
                        <h3>Install ffmpeg</h3>
                        <p>Audio/video processing toolkit for advanced audio handling</p>
                        <div class="step-status" id="ffmpeg-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="ffmpeg-progress"></div>
                        </div>
                    </div>
                </div>
                
                <div class="setup-step" id="step-test">
                    <div class="step-icon">✅</div>
                    <div class="step-content">
                        <h3>Test System</h3>
                        <p>Verifying everything works</p>
                        <div class="step-status" id="test-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="test-progress"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="setup-debug" style="margin: 24px 0;">
                <h3 style="margin-bottom: 12px; display: flex; align-items: center; gap: 8px; font-size: 16px;">
                    <span>🐛 Debug Console</span>
                    <button onclick="toggleDebugConsole()" style="background: none; border: 1px solid #444; color: #888; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">Toggle</button>
                </h3>
                <div id="debug-console" style="background: #000; border: 1px solid #333; border-radius: 6px; padding: 12px; font-family: 'Monaco', 'Menlo', monospace; font-size: 11px; line-height: 1.4; color: #a0a0a0; height: 200px; overflow-y: auto; white-space: pre-wrap;">Welcome to StenoAI Setup Debug Console
Commands and output will appear here...

</div>
            </div>
            
            <div class="setup-actions">
                <button class="btn btn-primary" id="setup-auto-start">Begin First-Time Setup</button>
                <button class="btn btn-primary" id="setup-continue" style="display: none;">Continue to App</button>
            </div>
        </div>
    </div>

    <!-- Settings Panel (slides in from right) -->
    <div class="settings-panel" id="settings-panel">
        <div class="settings-header">
            <h2>⚙️ Settings</h2>
            <button class="close-settings" onclick="toggleSettings()">✕</button>
        </div>
        
        <div class="settings-content">
            <div class="settings-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h3>🔧 Setup Wizard</h3>
                    <span style="font-size: 12px; color: #888;">Version: <span id="app-version">Loading...</span></span>
                </div>
                <p>Run the setup process again to reinstall dependencies or fix configuration issues.</p>
                
                <div class="setup-info">
                    <ul>
                        <li>Python virtual environment</li>
                        <li>Audio recording libraries</li>
                        <li>Whisper speech recognition</li>
                        <li>Ollama AI service and models</li>
                        <li>ffmpeg audio processing toolkit</li>
                    </ul>
                </div>
                
                <button class="btn btn-primary" id="run-setup-btn" onclick="runSetupFromSettings()">
                    Run Setup Wizard
                </button>
            </div>
            
            <div class="settings-section">
                <h3>🛠️ System Recovery</h3>
                <p>Tools to recover from stuck recordings or processing issues.</p>
                
                <button class="btn" id="clear-state-btn" onclick="clearSystemState()">
                    Clear Recording State
                </button>
                <p style="font-size: 12px; color: #888; margin-top: 8px;">
                    Use this if recordings appear stuck or the system won't start new recordings.
                </p>
                
            </div>
            
            <div class="settings-section">
                <h3>🔄 Updates</h3>
                <p>Check for the latest version of StenoAI. After downloading, you may need to run <code style="background: #333; padding: 2px 4px; border-radius: 2px; font-family: Monaco, monospace;">xattr -cr /Applications/StenoAI.app</code> before launching.</p>
                
                <button class="btn" id="test-update-btn" onclick="testUpdateCheck()">
                    Check for Updates
                </button>
                <p style="font-size: 12px; color: #888; margin-top: 8px;">
                    Manually check if a newer version is available on GitHub.
                </p>
                
            </div>
            
            <div class="settings-section">
                <h3>🧠 AI Prompts</h3>
                <p>View the prompts used for meeting summarization and analysis.</p>
                
                <h4>Summarization Prompt</h4>
                <div class="prompt-viewer" id="summarization-prompt">
                    Loading prompt...
                </div>
            </div>
        </div>
    </div>

    <!-- Debug Panel (slides in from right) -->
    <div class="debug-panel" id="debug-panel">
        <div class="debug-header">
            <h2>🔨 Debug Logs</h2>
            <button class="close-settings" onclick="toggleDebug()">✕</button>
        </div>
        
        <div class="debug-console" id="debug-console-panel">StenoAI Debug Console
Session started - waiting for activity...

</div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');
        
        // UI Elements
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const sessionNameInput = document.getElementById('session-name');
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const debugBtn = document.getElementById('debug-btn');
        const meetingsList = document.getElementById('meetings-list');
        const emptyState = document.getElementById('empty-state');
        const meetingDetail = document.getElementById('meeting-detail');
        const dropZone = document.getElementById('drop-zone');
        
        // Update elements
        const updateBanner = document.getElementById('update-banner');
        const updateVersion = document.getElementById('update-version');
        const viewReleaseBtn = document.getElementById('view-release-btn');
        const downloadUpdateBtn = document.getElementById('download-update-btn');
        const dismissUpdateBtn = document.getElementById('dismiss-update-btn');
        
        // Detail elements
        const detailTitle = document.getElementById('detail-title');
        const detailDate = document.getElementById('detail-date');
        const detailDuration = document.getElementById('detail-duration');
        const detailSummary = document.getElementById('detail-summary');
        const detailParticipants = document.getElementById('detail-participants');
        const detailKeyPoints = document.getElementById('detail-key-points');
        const detailActionItems = document.getElementById('detail-action-items');
        const detailTranscript = document.getElementById('detail-transcript');
        const reprocessBtn = document.getElementById('reprocess-btn');
        const copyTranscriptBtn = document.getElementById('copy-transcript-btn');
        
        // Setup elements
        const setupOverlay = document.getElementById('setup-overlay');
        const setupAutoStart = document.getElementById('setup-auto-start');
        const setupContinue = document.getElementById('setup-continue');
        
        let uiState = 'ready'; // ready, recording, processing, setup-needed
        let meetings = [];
        let filteredMeetings = [];
        let selectedMeeting = null;
        let recordingProcess = null;
        let statusCheckInterval = null;
        let processingMeeting = null; // Track which meeting is currently being reprocessed
        let searchQuery = '';
        let recordingStartTime = null;
        let recordingTimer = null;
        let processingMeetings = new Set();
        let meetingsLastLoaded = 0; // Cache timestamp
        
        // Update checking variables
        let updateInfo = null;
        let updateCheckInterval = null;
        
        // Utility functions
        function log(message) {
            console.log(`[${new Date().toLocaleTimeString()}] ${message}`);
        }
        
        function generateMeetingHash() {
            // Generate short hash for meeting names
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }
        
        function setStatus(status, message) {
            statusDot.className = `status-dot ${status}`;
            statusText.textContent = message;
            log(`Status: ${message}`);
        }
        
        function startRecordingTimer() {
            recordingStartTime = Date.now();
            recordingTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                setStatus('recording', `Recording... ${timeStr}`);
            }, 1000);
        }
        
        function stopRecordingTimer() {
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
            recordingStartTime = null;
        }
        
        function setUIState(state) {
            uiState = state;
            log(`UI State: ${state}`);
            
            // Update UI elements based on state
            switch(state) {
                case 'ready':
                    startBtn.style.display = 'inline-flex';
                    stopBtn.style.display = 'none';
                    startBtn.disabled = false;
                    sessionNameInput.disabled = false;
                    stopRecordingTimer();
                    setStatus('ready', 'Ready');
                    break;
                    
                case 'recording':
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-flex';
                    startBtn.disabled = true;
                    sessionNameInput.disabled = true;
                    stopBtn.disabled = false;
                    startRecordingTimer();
                    break;
                    
                case 'processing':
                    startBtn.style.display = 'inline-flex';
                    stopBtn.style.display = 'none';
                    startBtn.disabled = true;
                    sessionNameInput.disabled = true;
                    stopRecordingTimer();
                    setStatus('processing', 'Processing...');
                    break;
            }
        }
        
        function startStatusMonitoring() {
            // Only check status when we think we're recording
            if (statusCheckInterval) clearInterval(statusCheckInterval);
            
            statusCheckInterval = setInterval(async () => {
                if (uiState === 'recording') {
                    try {
                        // Check if microphone permission was revoked during recording
                        const micResult = await ipcRenderer.invoke('check-microphone-permission');
                        if (!micResult.success || micResult.status !== 'granted') {
                            log('🚫 Microphone permission revoked during recording - stopping');
                            alert('❌ Microphone access was revoked! Recording stopped.\n\nPlease grant microphone permission to continue recording.');
                            setUIState('ready');
                            stopStatusMonitoring();
                            showSetupOverlay([]);
                            return;
                        }
                        
                        const result = await ipcRenderer.invoke('get-status');
                        if (result.success && !result.status.includes('RECORDING')) {
                            // Backend says not recording but UI thinks it is - sync up
                            log('Backend/UI state mismatch - syncing');
                            setUIState('ready');
                            stopStatusMonitoring();
                        }
                    } catch (error) {
                        log(`Status check failed: ${error.message}`);
                    }
                }
            }, 10000); // Check every 10 seconds only when recording
        }
        
        function stopStatusMonitoring() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
                statusCheckInterval = null;
            }
        }
        
        
        function formatDate(dateString) {
            if (!dateString) return 'Unknown date';
            try {
                return new Date(dateString).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch {
                return 'Unknown date';
            }
        }
        
        function formatDuration(startTime, endTime) {
            if (!startTime || !endTime) return 'Unknown';
            try {
                const start = new Date(startTime);
                const end = new Date(endTime);
                const minutes = Math.round((end - start) / 60000);
                return `${minutes} min`;
            } catch {
                return 'Unknown';
            }
        }
        
        // Delete meeting function
        async function deleteMeeting(index, event) {
            event.stopPropagation(); // Prevent selecting the meeting
            
            const meeting = filteredMeetings[index];
            if (!meeting) return;
            
            const confirmed = confirm(`Delete meeting "${meeting.session_info?.name || 'Untitled Meeting'}"?\n\nThis will delete the transcript, summary, and all associated files.`);
            if (!confirmed) return;
            
            try {
                // Pass the entire meeting object to the backend
                const result = await ipcRenderer.invoke('delete-meeting', meeting);
                
                if (result.success) {
                    log(`Meeting deleted: ${result.message}`);
                    
                    // Remove meeting from local arrays
                    meetings = meetings.filter(m => m !== meeting);
                    filteredMeetings = filteredMeetings.filter(m => m !== meeting);
                    
                    // Re-render the meetings list
                    filterMeetings();
                    
                    // Clear selected meeting if it was deleted
                    if (selectedMeeting === meeting) {
                        selectedMeeting = null;
                        emptyState.style.display = 'flex';
                        meetingDetail.classList.remove('show');
                    }
                } else {
                    log(`Failed to delete meeting: ${result.error}`);
                    alert(`Failed to delete meeting: ${result.error}`);
                }
            } catch (error) {
                log(`Error deleting meeting: ${error.message}`);
                alert(`Error deleting meeting: ${error.message}`);
            }
        }
        
        // Filter meetings based on search query
        function filterMeetings() {
            if (!searchQuery.trim()) {
                filteredMeetings = [...meetings];
            } else {
                const query = searchQuery.toLowerCase();
                filteredMeetings = meetings.filter(meeting => {
                    const name = (meeting.session_info?.name || '').toLowerCase();
                    const summary = (meeting.summary || '').toLowerCase();
                    const keyPoints = (meeting.key_points || []).join(' ').toLowerCase();
                    const actionItems = (meeting.action_items || []).join(' ').toLowerCase();
                    
                    return name.includes(query) || 
                           summary.includes(query) || 
                           keyPoints.includes(query) || 
                           actionItems.includes(query);
                });
            }
            renderMeetingsList();
        }
        
        // Load meetings from backend with caching
        async function loadMeetings(forceRefresh = false) {
            const now = Date.now();
            
            // Use cache if data is less than 30 seconds old and not forced refresh
            if (!forceRefresh && meetings.length > 0 && (now - meetingsLastLoaded) < 30000) {
                log('Using cached meetings data');
                filterMeetings();
                return;
            }
            
            // Show loading state only if we don't have cached data
            if (meetings.length === 0) {
                meetingsList.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #666;">
                        <div style="font-size: 24px; margin-bottom: 8px;">⟳</div>
                        <p>Loading meetings...</p>
                    </div>
                `;
            }
            
            try {
                const result = await ipcRenderer.invoke('list-meetings');
                if (result.success) {
                    meetings = result.meetings || [];
                    meetingsLastLoaded = now;
                    filterMeetings(); // Apply current search filter
                    log(`Loaded ${meetings.length} meetings`);
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                log(`Failed to load meetings: ${error.message}`);
                // Only show error if we don't have cached data
                if (meetings.length === 0) {
                    meetingsList.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #666;">
                            <div style="font-size: 24px; margin-bottom: 8px;">⚠️</div>
                            <p>Failed to load meetings</p>
                            <p style="font-size: 12px; margin-top: 4px;">Using cached data if available</p>
                        </div>
                    `;
                } else {
                    // We have cached data, just log the error
                    log('Using cached meetings data due to load failure');
                    filterMeetings();
                }
            }
        }
        
        // Render meetings list
        function renderMeetingsList() {
            if (filteredMeetings.length === 0 && searchQuery.trim()) {
                meetingsList.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #666;">
                        <div style="font-size: 24px; margin-bottom: 8px;">🔍</div>
                        <p>No meetings match "${searchQuery}"</p>
                        <p style="font-size: 12px; margin-top: 4px;">Try a different search term</p>
                    </div>
                `;
                return;
            }
            
            if (meetings.length === 0) {
                meetingsList.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #666;">
                        <div style="font-size: 24px; margin-bottom: 8px;">🎙️</div>
                        <p>No meetings recorded yet</p>
                        <p style="font-size: 12px; margin-top: 4px;">Start recording to see your meetings here</p>
                    </div>
                `;
                return;
            }
            
            meetingsList.innerHTML = filteredMeetings.map((meeting, index) => {
                const isProcessing = processingMeetings.has(meeting.session_info?.name);
                return `
                <div class="meeting-item ${isProcessing ? 'processing' : ''}" data-index="${index}">
                    ${isProcessing ? '<div class="processing-overlay"><div class="processing-indicator"><div class="processing-spinner"></div>Processing...</div></div>' : ''}
                    <button class="meeting-delete" onclick="deleteMeeting(${index}, event)" title="Delete meeting">✕</button>
                    <h3>${meeting.session_info?.name || 'Untitled Meeting'}</h3>
                    <div class="meeting-meta">
                        <span class="meeting-date">${formatDate(meeting.session_info?.processed_at)}</span>
                    </div>
                    <div class="meeting-preview">
                        ${(meeting.summary || 'No summary available').substring(0, 100)}...
                    </div>
                </div>
                `;
            }).join('');
            
            // Add click handlers
            document.querySelectorAll('.meeting-item').forEach(item => {
                item.addEventListener('click', () => {
                    const index = parseInt(item.dataset.index);
                    selectMeeting(index);
                });
            });
        }
        
        // Select and display meeting details
        function selectMeeting(index) {
            selectedMeeting = filteredMeetings[index];
            if (!selectedMeeting) return;
            
            // Update active state
            document.querySelectorAll('.meeting-item').forEach((item, i) => {
                item.classList.toggle('active', i === index);
            });
            
            // Show meeting details
            emptyState.style.display = 'none';
            meetingDetail.classList.add('show');
            
            // Populate details
            detailTitle.textContent = selectedMeeting.session_info?.name || 'Untitled Meeting';
            detailDate.textContent = formatDate(selectedMeeting.session_info?.processed_at);
            const durationText = selectedMeeting.session_info?.duration_seconds ? 
                (() => {
                    const totalSecs = selectedMeeting.session_info.duration_seconds;
                    const hours = Math.floor(totalSecs / 3600);
                    const mins = Math.floor((totalSecs % 3600) / 60);
                    const secs = totalSecs % 60;
                    
                    if (hours > 0) return `🕒 Meeting Duration: ${hours}h ${mins}m`;
                    if (mins > 0) return `🕒 Meeting Duration: ${mins}m ${secs}s`;
                    return `🕒 Meeting Duration: ${secs}s`;
                })() :
                (selectedMeeting.session_info?.duration_minutes ? 
                    `🕒 Meeting Duration: ${selectedMeeting.session_info.duration_minutes} minutes` : '📄 Processed');
            detailDuration.textContent = durationText;
            
            detailSummary.textContent = selectedMeeting.summary || 'No summary available';
            
            // Participants
            if (selectedMeeting.participants && selectedMeeting.participants.length > 0) {
                detailParticipants.textContent = selectedMeeting.participants.join(', ');
            } else {
                detailParticipants.innerHTML = '<span style="color: #666;">No participants identified</span>';
            }
            
            // Key points
            detailKeyPoints.innerHTML = '';
            if (selectedMeeting.key_points && selectedMeeting.key_points.length > 0) {
                selectedMeeting.key_points.forEach(point => {
                    const li = document.createElement('li');
                    li.textContent = point;
                    detailKeyPoints.appendChild(li);
                });
            } else {
                detailKeyPoints.innerHTML = '<li style="color: #666;">No key points identified</li>';
            }
            
            // Action items
            detailActionItems.innerHTML = '';
            if (selectedMeeting.action_items && selectedMeeting.action_items.length > 0) {
                selectedMeeting.action_items.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item;
                    detailActionItems.appendChild(li);
                });
            } else {
                detailActionItems.innerHTML = '<li style="color: #666;">No action items identified</li>';
            }
            
            // Transcript
            detailTranscript.textContent = selectedMeeting.transcript || 'No transcript available';
            
            // Set reprocess button state based on whether this meeting is currently processing
            const isCurrentlyProcessing = processingMeeting && processingMeeting.session_info?.summary_file === selectedMeeting.session_info?.summary_file;
            
            if (isCurrentlyProcessing) {
                // Restore processing state
                reprocessBtn.disabled = true;
                reprocessBtn.classList.add('processing');
                reprocessBtn.innerHTML = '<div class="reprocess-spinner"></div>Processing...';
            } else {
                // Normal state
                reprocessBtn.disabled = false;
                reprocessBtn.classList.remove('processing');
                reprocessBtn.innerHTML = 'Reprocess';
            }
            
            // TEMPORARY: Show reprocess button for all meetings (for testing)
            reprocessBtn.style.display = 'flex';
            
            /* ORIGINAL LOGIC (commented out for testing):
            // Show/hide reprocess button based on meeting quality
            const hasFailedSummary = (
                !selectedMeeting.summary || 
                selectedMeeting.summary.includes('No transcript was generated') ||
                selectedMeeting.summary.includes('detailed analysis failed') ||
                selectedMeeting.summary.includes('not fully supported') ||
                (selectedMeeting.overview && (
                    selectedMeeting.overview.includes('No transcript was generated') ||
                    selectedMeeting.overview.includes('detailed analysis failed') ||
                    selectedMeeting.overview.includes('not fully supported')
                ))
            );
            
            const hasNoParticipants = !selectedMeeting.participants || selectedMeeting.participants.length === 0;
            const hasNoKeyPoints = !selectedMeeting.key_points || selectedMeeting.key_points.length === 0;
            
            // Show reprocess button if meeting appears to have failed summarization
            if (hasFailedSummary || (hasNoParticipants && hasNoKeyPoints && selectedMeeting.transcript && selectedMeeting.transcript.length > 100)) {
                reprocessBtn.style.display = 'flex';
            } else {
                reprocessBtn.style.display = 'none';
            }
            */
        }
        
        
        // Manual start/stop recording functions
        startBtn.addEventListener('click', async () => {
            // Check microphone permission before allowing recording
            try {
                const micResult = await ipcRenderer.invoke('check-microphone-permission');
                if (!micResult.success || micResult.status !== 'granted') {
                    log('🚫 Cannot start recording - microphone permission denied');
                    
                    // Show clear error message
                    const micStatus = micResult.status || 'unknown';
                    alert(`❌ Recording blocked: Microphone permission is ${micStatus}.\n\nStenoAI requires microphone access to record meetings. Please grant permission and try again.`);
                    
                    // Force show setup wizard to fix the issue
                    showSetupOverlay([]);
                    return;
                }
            } catch (error) {
                log(`🚫 Failed to check microphone permission: ${error.message}`);
                alert('❌ Cannot verify microphone permission. Please ensure the app has proper access.');
                return;
            }
            
            // Generate session name if empty or use Meeting-HASH format
            let sessionName = sessionNameInput.value.trim();
            if (!sessionName || sessionName === 'Meeting') {
                sessionName = `Meeting-${generateMeetingHash()}`;
                sessionNameInput.value = sessionName;
            }
            
            log(`🎙️ Starting recording: ${sessionName}`);
            setUIState('recording');
            
            try {
                const result = await ipcRenderer.invoke('start-recording-ui', sessionName);
                if (result.success) {
                    log(`Recording started: ${result.message}`);
                    startStatusMonitoring();
                } else {
                    log(`Failed to start: ${result.error}`);
                    setUIState('ready');
                }
            } catch (error) {
                log(`🚫 Start error: ${error.message}`);
                setUIState('ready');
            }
        });
        
        stopBtn.addEventListener('click', async () => {
            log('⏹️ Stopping recording...');
            setUIState('processing');
            stopStatusMonitoring();
            
            // Add current session to processing list immediately
            const currentSessionName = sessionNameInput.value.trim() || 'Meeting';
            processingMeetings.add(currentSessionName);
            
            // Add a temporary meeting entry to show processing
            const tempMeeting = {
                session_info: {
                    name: currentSessionName,
                    processed_at: new Date().toISOString(),
                    duration_seconds: null
                },
                summary: 'Pending...',
                key_points: [],
                action_items: [],
                transcript: ''
            };
            
            // Add to beginning of meetings array temporarily
            meetings.unshift(tempMeeting);
            filterMeetings(); // Update UI to show processing state
            
            try {
                const result = await ipcRenderer.invoke('stop-recording-ui');
                if (result.success) {
                    log(`Recording stopped: ${result.message}`);
                    log('🔄 Processing audio - transcription and summarization running in background');
                    log('💡 Meeting list will refresh automatically when processing completes');
                    
                    // Return to ready state quickly so user can start another recording if needed
                    setTimeout(() => {
                        setUIState('ready');
                        sessionNameInput.value = 'Meeting';
                    }, 5000); // 5 seconds
                    
                } else {
                    log(`Failed to stop: ${result.error}`);
                    setUIState('ready');
                    processingMeetings.delete(currentSessionName);
                    renderMeetingsList();
                }
            } catch (error) {
                log(`🚫 Stop error: ${error.message}`);
                setUIState('ready');
                processingMeetings.delete(currentSessionName);
                renderMeetingsList();
            }
        });
        
        // Search functionality
        const searchInput = document.getElementById('search-input');
        searchInput.addEventListener('input', (e) => {
            searchQuery = e.target.value;
            filterMeetings();
        });
        
        
        // File drop handling
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('active');
        });
        
        document.addEventListener('dragleave', (e) => {
            if (!e.relatedTarget) {
                dropZone.classList.remove('active');
            }
        });
        
        document.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('active');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type.startsWith('audio/') || file.name.match(/\.(wav|mp3|m4a|aac)$/i)) {
                    log(`Processing dropped file: ${file.name}`);
                    setStatus('processing', 'Processing file...');
                    
                    try {
                        const sessionName = file.name.replace(/\.[^/.]+$/, ''); // Remove extension
                        processingMeetings.add(sessionName);
                        renderMeetingsList(); // Update UI to show processing state
                        const result = await ipcRenderer.invoke('process-recording', file.path, sessionName);
                        
                        if (result.success) {
                            log('File processed successfully');
                            setStatus('ready', 'Complete');
                            processingMeetings.delete(sessionName);
                            
                            // Force refresh meetings list after processing
                            setTimeout(() => {
                                loadMeetings(true);
                            }, 1000);
                        } else {
                            log(`Processing failed: ${result.error}`);
                            setStatus('ready', 'Processing failed');
                            processingMeetings.delete(sessionName);
                            renderMeetingsList();
                        }
                    } catch (error) {
                        log(`Processing error: ${error.message}`);
                        setStatus('ready', 'Error');
                        processingMeetings.delete(sessionName);
                        renderMeetingsList();
                    }
                } else {
                    log('Invalid file type. Please drop an audio file.');
                }
            }
        });
        
        // Check initial recording status once
        async function checkInitialStatus() {
            try {
                const result = await ipcRenderer.invoke('get-status');
                if (result.success && result.status.includes('RECORDING')) {
                    log('Found active recording session - syncing UI state');
                    setUIState('recording');
                    startStatusMonitoring();
                } else {
                    setUIState('ready');
                }
            } catch (error) {
                log(`Failed to check initial status: ${error.message}`);
                setUIState('ready');
            }
        }

        // Auto-clear state on startup
        async function initializeApp() {
            // Clear debug logs for fresh start
            clearDebugLog();
            
            log('Initializing Steno Recorder...');
            
            // Request notification permission early (non-blocking)
            if (Notification.permission === 'default') {
                Notification.requestPermission().catch(() => {}); // Don't wait for this
            }
            
            // Parallel startup: Load meetings first (user sees content immediately),
            // then clear state and check status in background
            const startTime = Date.now();
            
            try {
                // Start loading meetings immediately (most important for user experience)
                const meetingsPromise = loadMeetings();
                
                // Do maintenance tasks in parallel
                const maintenancePromise = Promise.all([
                    ipcRenderer.invoke('clear-state').catch(err => 
                        log(`State clear failed: ${err.message}`)
                    ),
                    checkInitialStatus().catch(err => 
                        log(`Status check failed: ${err.message}`)
                    )
                ]);
                
                // Wait for meetings to load (priority), maintenance can finish in background
                await meetingsPromise;
                log(`Meetings loaded (${Date.now() - startTime}ms)`);
                
                // Wait for maintenance to complete
                await maintenancePromise;
                
            } catch (error) {
                log(`Initialization error: ${error.message}`);
                // Continue anyway - app should still be usable
            }
            
            log(`Steno Recorder ready (${Date.now() - startTime}ms total)`);
        }

        // Startup setup flow
        let setupInProgress = false;
        
        setupAutoStart.addEventListener('click', async () => {
            if (setupInProgress) return;
            await runSetupProcess();
        });
        
        setupContinue.addEventListener('click', () => {
            setupOverlay.style.display = 'none';
            // Refresh meetings after setup completion to ensure fresh data
            loadMeetings(true);
        });
        
        // Settings button click handler
        settingsBtn.addEventListener('click', () => {
            toggleSettings();
        });
        
        // Debug button click handler
        debugBtn.addEventListener('click', () => {
            toggleDebug();
        });
        
        // Reprocess button click handler
        reprocessBtn.addEventListener('click', async () => {
            if (!selectedMeeting) return;
            
            const summaryFile = selectedMeeting.session_info?.summary_file;
            if (!summaryFile) {
                log('❌ No summary file found for reprocessing');
                return;
            }
            
            // Track which meeting is being processed
            processingMeeting = selectedMeeting;
            
            // Show processing state
            reprocessBtn.disabled = true;
            reprocessBtn.classList.add('processing');
            reprocessBtn.innerHTML = '<div class="reprocess-spinner"></div>Processing...';
            
            const meetingBeingProcessed = selectedMeeting; // Capture the meeting being processed
            log(`🔄 Reprocessing meeting: ${meetingBeingProcessed.session_info?.name}`);
            
            try {
                // Call main process to reprocess the meeting
                const result = await ipcRenderer.invoke('reprocess-meeting', summaryFile);
                
                if (result.success) {
                    log('✅ Meeting reprocessed successfully');
                    
                    // Send notification for reprocessing completion
                    if (Notification.permission === 'granted') {
                        new Notification('StenoAI - Reprocessing Complete', {
                            body: `"${meetingBeingProcessed.session_info?.name || 'Meeting'}" has been reanalyzed`,
                            icon: 'build/icon.png',
                            requireInteraction: false
                        });
                    }
                    
                    // Reload meetings to show updated data
                    await loadMeetings(true);
                    // Re-select the current meeting to show updated content
                    const updatedMeetingIndex = filteredMeetings.findIndex(m => 
                        m.session_info?.summary_file === summaryFile
                    );
                    if (updatedMeetingIndex !== -1) {
                        selectMeeting(updatedMeetingIndex);
                    }
                } else {
                    log(`❌ Reprocessing failed: ${result.error}`);
                }
            } catch (error) {
                log(`❌ Reprocessing error: ${error.message}`);
            } finally {
                // Clear processing tracker
                processingMeeting = null;
                
                // Reset button state only if we're still viewing the same meeting
                if (selectedMeeting && selectedMeeting.session_info?.summary_file === summaryFile) {
                    reprocessBtn.disabled = false;
                    reprocessBtn.classList.remove('processing');
                    reprocessBtn.innerHTML = 'Reprocess';
                }
            }
        });
        
        // Copy transcript to clipboard
        copyTranscriptBtn.addEventListener('click', async () => {
            try {
                const transcriptText = detailTranscript.textContent || '';
                if (!transcriptText || transcriptText === 'No transcript available') {
                    log('❌ No transcript available to copy');
                    return;
                }
                
                await navigator.clipboard.writeText(transcriptText);
                
                // Visual feedback
                copyTranscriptBtn.classList.add('copied');
                copyTranscriptBtn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20,6 9,17 4,12"></polyline>
                    </svg>
                `;
                
                // Reset after 2 seconds
                setTimeout(() => {
                    copyTranscriptBtn.classList.remove('copied');
                    copyTranscriptBtn.innerHTML = `
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                    `;
                }, 2000);
                
                log('📋 Transcript copied to clipboard');
            } catch (error) {
                log(`❌ Failed to copy transcript: ${error.message}`);
            }
        });
        
        // Listen for debug messages from backend
        ipcRenderer.on('debug-log', (event, message) => {
            debugLog(message);
        });
        
        async function runSetupProcess() {
            setupInProgress = true;
            setupAutoStart.style.display = 'none';
            
            // Clear and initialize debug console
            const debugConsole = document.getElementById('debug-console');
            debugConsole.textContent = 'StenoAI Setup Debug Console - Setup Started\n';
            debugLog('='.repeat(50));
            debugLog('Starting First-Time Setup Process');
            debugLog('='.repeat(50));
            
            const steps = [
                { id: 'step-microphone', handler: 'request-microphone-permission', name: 'Microphone Access' },
                { id: 'step-system', handler: 'setup-system-check', name: 'System Check' },
                { id: 'step-python', handler: 'setup-python', name: 'Python Dependencies' },
                { id: 'step-whisper', handler: 'setup-whisper', name: 'Whisper Installation' },
                { id: 'step-ollama', handler: 'setup-ollama-and-model', name: 'Ollama + AI Model' },
                { id: 'step-ffmpeg', handler: 'setup-ffmpeg', name: 'ffmpeg Installation' },
                { id: 'step-test', handler: 'setup-test', name: 'System Test' }
            ];
            
            for (const step of steps) {
                const element = document.getElementById(step.id);
                const statusElement = document.getElementById(step.id.replace('step-', '') + '-status');
                
                // Mark as active
                element.classList.remove('completed', 'failed');
                element.classList.add('active');
                statusElement.textContent = 'Running...';
                
                // Log to debug console
                debugLog(`\n>>> Starting: ${step.name}`);
                debugLog(`Command: ${step.handler}`);
                
                try {
                    const result = await ipcRenderer.invoke(step.handler);
                    
                    if (result.success) {
                        element.classList.remove('active');
                        element.classList.add('completed');
                        statusElement.textContent = result.message || 'Completed';
                        debugLog(`✅ SUCCESS: ${result.message || 'Completed'}`);
                        
                        // Special handling for microphone permission completion
                        if (step.id === 'step-microphone') {
                            statusElement.textContent = 'Permission granted!';
                            debugLog('Microphone permission granted - can proceed with other setup steps');
                        }
                        
                    } else {
                        element.classList.remove('active');
                        element.classList.add('failed');
                        statusElement.textContent = result.error || 'Failed';
                        
                        debugLog(`❌ FAILED: ${result.error || 'Failed'}`);
                        
                        // Show detailed error in debug console if available
                        if (result.details) {
                            debugLog('--- Error Details ---');
                            debugLog(result.details);
                            debugLog('--- End Error Details ---');
                        }
                        
                        // Show retry button on failure
                        setupAutoStart.textContent = 'Retry Setup';
                        setupAutoStart.style.display = 'block';
                        setupInProgress = false;
                        return;
                    }
                } catch (error) {
                    element.classList.remove('active');
                    element.classList.add('failed');
                    statusElement.textContent = 'Failed';
                    
                    debugLog(`❌ EXCEPTION: ${error.message}`);
                    debugLog(`Stack trace: ${error.stack}`);
                    
                    // Show retry button on failure
                    setupAutoStart.textContent = 'Retry Setup';
                    setupAutoStart.style.display = 'block';
                    setupInProgress = false;
                    return;
                }
                
                // Small delay between steps
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            log('🎉 Setup completed successfully!');
            debugLog('\n' + '='.repeat(50));
            debugLog('🎉 Setup completed successfully!');
            debugLog('All components installed and tested.');
            debugLog('='.repeat(50));
            
            setupContinue.style.display = 'block';
            setupInProgress = false;
        }
        
        // Smooth startup with automatic setup detection
        async function runStartupCheck() {
            log('🔍 Checking system setup...');
            
            try {
                // Check microphone permission and system setup together
                const micResult = await ipcRenderer.invoke('check-microphone-permission');
                const micGranted = micResult.success && micResult.status === 'granted';
                
                const result = await ipcRenderer.invoke('startup-setup-check');
                const systemReady = result.success && result.allGood;
                
                if (micGranted && systemReady) {
                    // Everything is ready - continue to main app
                    log('System ready!');
                    return;
                } else {
                    // Show unified setup wizard (includes microphone + system setup)
                    log('⚙️ Setup needed - showing unified setup wizard');
                    showSetupOverlay(result.checks || []);
                }
            } catch (error) {
                log(`Setup check failed: ${error.message}`);
                // Show setup overlay as fallback
                log('🆕 First time setup detected');
                showSetupOverlay([]);
            }
        }
        
        async function showSetupOverlay(checks) {
            setupOverlay.style.display = 'flex';
            
            // Show ALL steps and reset their state
            document.querySelectorAll('.setup-step').forEach(step => {
                step.style.display = 'flex'; // Make sure all steps are visible
                step.classList.remove('active', 'completed', 'failed');
            });
            
            // Check and update microphone permission status
            try {
                const micResult = await ipcRenderer.invoke('check-microphone-permission');
                const micStep = document.getElementById('step-microphone');
                const micStatus = document.getElementById('microphone-status');
                
                if (micResult.success && micResult.status === 'granted') {
                    micStep.classList.add('completed');
                    micStatus.textContent = 'Permission granted';
                } else {
                    micStep.classList.add('failed');
                    micStatus.textContent = 'Requesting microphone permission...';
                    
                    // Automatically request microphone permission if missing
                    log('🎤 Microphone permission missing - automatically requesting...');
                    setTimeout(async () => {
                        try {
                            const requestResult = await ipcRenderer.invoke('request-microphone-permission');
                            if (requestResult.success && requestResult.granted) {
                                micStep.classList.remove('failed');
                                micStep.classList.add('completed');
                                micStatus.textContent = 'Permission granted!';
                                log('✅ Microphone permission granted automatically');
                            } else {
                                micStatus.textContent = 'Permission denied - please grant in System Preferences';
                                log('❌ Microphone permission denied by user');
                            }
                        } catch (error) {
                            micStatus.textContent = 'Failed to request permission';
                            log(`❌ Error requesting microphone permission: ${error.message}`);
                        }
                    }, 1000); // Small delay to show the status message
                }
            } catch (error) {
                console.error('Failed to check microphone permission:', error);
            }
            
            // Update other step statuses based on backend check
            checks.forEach(check => {
                const [status, detail] = check;
                updateStepStatus(status, detail);
            });
            
            // Show appropriate button
            const hasFailures = checks.length === 0 || checks.some(([status]) => status.startsWith('❌'));
            if (hasFailures || checks.length === 0) {
                setupAutoStart.style.display = 'block';
                setupAutoStart.textContent = checks.length === 0 ? 'Begin First-Time Setup' : 'Install Missing Dependencies';
                setupContinue.style.display = 'none';
            } else {
                setupContinue.style.display = 'block';
                setupAutoStart.style.display = 'none';
            }
        }
        
        function updateStepStatus(status, detail) {
            // Map backend check results to UI steps - only show setup for missing installations
            if (status.includes('Python')) {
                updateStep('step-system', status.startsWith('✅') ? 'completed' : 'failed', detail);
            } else if (status.includes('sounddevice')) {
                updateStep('step-python', status.startsWith('✅') ? 'completed' : 'failed', detail);
            } else if (status.includes('whisper')) {
                updateStep('step-whisper', status.startsWith('✅') ? 'completed' : 'failed', detail);
            } else if (status.includes('Ollama') || status.includes('Llama')) {
                // Only show as failed if actually missing, not just service down
                if (detail.includes('not installed') || detail.includes('missing')) {
                    updateStep('step-ollama', status.startsWith('✅') ? 'completed' : 'failed', detail);
                } else if (status.startsWith('✅')) {
                    updateStep('step-ollama', 'completed', detail);
                }
            }
        }
        
        function updateStep(stepId, state, message) {
            const element = document.getElementById(stepId);
            const statusElement = document.getElementById(stepId.replace('step-', '') + '-status');
            
            element.classList.remove('active', 'completed', 'failed');
            element.classList.add(state);
            statusElement.textContent = message;
        }

        // Listen for automatic meetings refresh from backend (legacy - kept for compatibility)
        ipcRenderer.on('meetings-refreshed', (event, meetingsData) => {
            log('Processing complete! Meeting list automatically refreshed');
            meetings = meetingsData || [];
            filterMeetings(); // Apply current search filter and render
        });
        
        // Listen for processing completion events
        ipcRenderer.on('processing-complete', (event, data) => {
            log(`Processing complete for: ${data.sessionName}`);
            processingMeetings.delete(data.sessionName);
            
            if (data.success) {
                if (data.meetingData) {
                    // Update the specific meeting with processed data
                    const tempMeetingIndex = meetings.findIndex(meeting => 
                        meeting.session_info?.name === data.sessionName && meeting.summary === 'Pending...'
                    );
                    
                    if (tempMeetingIndex !== -1) {
                        // Replace temporary meeting with processed data
                        meetings[tempMeetingIndex] = data.meetingData;
                        meetingsLastLoaded = Date.now(); // Update cache timestamp
                    } else {
                        // Add new meeting if temp entry not found
                        meetings.unshift(data.meetingData);
                        meetingsLastLoaded = Date.now(); // Update cache timestamp
                    }
                    
                    // Re-render the meetings list with updated data
                    filterMeetings();
                } else {
                    // No meetingData provided - force refresh from backend
                    log('No meeting data in completion event - forcing refresh');
                    loadMeetings(true);
                }
                
                // Show native notification
                if (Notification.permission === 'granted') {
                    new Notification('StenoAI - Meeting Notes Ready', {
                        body: `"${data.sessionName}" has been transcribed and summarized`,
                        icon: 'build/icon.png',
                        requireInteraction: false
                    });
                }
                
                setStatus('ready', 'Processing complete');
            } else {
                // Remove temporary meeting entry on failure
                meetings = meetings.filter(meeting => 
                    !(meeting.session_info?.name === data.sessionName && meeting.summary === 'Pending...')
                );
                
                setStatus('ready', 'Processing failed');
                log(`Processing failed: ${data.error}`);
                filterMeetings();
            }
        });
        
        // Settings panel functionality
        let settingsVisible = false;
        
        function toggleSettings() {
            const settingsPanel = document.getElementById('settings-panel');
            settingsVisible = !settingsVisible;
            
            if (settingsVisible) {
                settingsPanel.style.right = '0';
                loadPrompts();
            } else {
                settingsPanel.style.right = '-400px';
            }
        }
        
        let debugVisible = false;
        
        function toggleDebug() {
            const debugPanel = document.getElementById('debug-panel');
            debugVisible = !debugVisible;
            
            if (debugVisible) {
                debugPanel.style.right = '0';
            } else {
                debugPanel.style.right = '-500px';
            }
        }
        
        async function loadPrompts() {
            try {
                const prompts = await ipcRenderer.invoke('get-ai-prompts');
                const promptElement = document.getElementById('summarization-prompt');
                
                if (prompts.success) {
                    promptElement.textContent = prompts.summarization || 'Prompt not available';
                } else {
                    promptElement.textContent = 'Failed to load prompts';
                }
            } catch (error) {
                document.getElementById('summarization-prompt').textContent = 'Failed to load prompts';
            }
            
            // Load app version
            try {
                const versionInfo = await ipcRenderer.invoke('get-app-version');
                const versionElement = document.getElementById('app-version');
                
                if (versionInfo.success) {
                    versionElement.textContent = `v${versionInfo.version}`;
                } else {
                    versionElement.textContent = 'Unknown';
                }
            } catch (error) {
                document.getElementById('app-version').textContent = 'Unknown';
            }
        }
        
        async function runSetupFromSettings() {
            const btn = document.getElementById('run-setup-btn');
            btn.textContent = 'Running Setup...';
            btn.disabled = true;
            
            try {
                // Show setup overlay in main window
                document.getElementById('setup-overlay').style.display = 'flex';
                
                // Run the setup process
                await runSetupProcess();
                
                btn.textContent = 'Setup Complete!';
                setTimeout(() => {
                    btn.textContent = 'Run Setup Wizard';
                    btn.disabled = false;
                }, 3000);
            } catch (error) {
                console.error('Setup failed:', error);
                btn.textContent = 'Setup Failed - Try Again';
                btn.disabled = false;
            }
        }
        
        function toggleDebugConsole() {
            const console = document.getElementById('debug-console');
            if (console.style.display === 'none') {
                console.style.display = 'block';
            } else {
                console.style.display = 'none';
            }
        }
        
        function clearDebugLog() {
            // Clear both debug consoles
            const setupConsole = document.getElementById('debug-console');
            if (setupConsole) {
                setupConsole.textContent = 'StenoAI Setup Debug Console\nCommands and output will appear here...\n\n';
            }
            
            const debugPanel = document.getElementById('debug-console-panel');
            if (debugPanel) {
                debugPanel.textContent = 'StenoAI Debug Console\nSession started - ready for activity...\n\n';
            }
        }

        function debugLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            const formattedMessage = `[${timestamp}] ${message}\n`;
            
            // Log to setup wizard console if it exists (during setup)
            const setupConsole = document.getElementById('debug-console');
            if (setupConsole) {
                setupConsole.textContent += formattedMessage;
                setupConsole.scrollTop = setupConsole.scrollHeight;
            }
            
            // Always log to debug panel
            const debugPanel = document.getElementById('debug-console-panel');
            if (debugPanel) {
                debugPanel.textContent += formattedMessage;
                debugPanel.scrollTop = debugPanel.scrollHeight;
            }
        }
        
        
        async function clearSystemState() {
            const btn = document.getElementById('clear-state-btn');
            btn.textContent = 'Clearing...';
            btn.disabled = true;
            
            try {
                const result = await ipcRenderer.invoke('clear-state');
                if (result.success) {
                    btn.textContent = 'State Cleared!';
                    log('Manual state clear successful');
                } else {
                    btn.textContent = 'Clear Failed';
                    log('Manual state clear failed: ' + result.error);
                }
                
                setTimeout(() => {
                    btn.textContent = 'Clear Recording State';
                    btn.disabled = false;
                }, 2000);
            } catch (error) {
                console.error('Clear state failed:', error);
                btn.textContent = 'Clear Failed';
                btn.disabled = false;
                setTimeout(() => {
                    btn.textContent = 'Clear Recording State';
                }, 2000);
            }
        }
        
        async function testUpdateCheck() {
            const btn = document.getElementById('test-update-btn');
            btn.textContent = 'Checking...';
            btn.disabled = true;
            
            try {
                // Clear any previous dismissal to force showing banner
                sessionStorage.removeItem('updateDismissed');
                
                await checkForUpdates();
                
                btn.textContent = 'Check Complete!';
                setTimeout(() => {
                    btn.textContent = 'Test Update Check';
                    btn.disabled = false;
                }, 2000);
            } catch (error) {
                console.error('Update check test failed:', error);
                btn.textContent = 'Test Failed';
                btn.disabled = false;
                setTimeout(() => {
                    btn.textContent = 'Test Update Check';
                }, 2000);
            }
        }
        
        // Update checking functions
        async function checkForUpdates() {
            try {
                log('🔍 Checking for updates...');
                const result = await ipcRenderer.invoke('check-for-updates');
                
                if (result.success) {
                    updateInfo = result;
                    log(`Update check: Current ${result.currentVersion}, Latest ${result.latestVersion}`);
                    
                    if (result.updateAvailable) {
                        showUpdateBanner(result);
                    }
                } else {
                    log(`Update check failed: ${result.error}`);
                }
            } catch (error) {
                log(`Update check error: ${error.message}`);
            }
        }
        
        function showUpdateBanner(info) {
            updateVersion.textContent = `v${info.latestVersion}`;
            updateBanner.classList.add('show');
            document.querySelector('.header').classList.add('with-update-banner');
            
            log(`🚀 Update available: v${info.latestVersion}`);
        }
        
        function hideUpdateBanner() {
            updateBanner.classList.remove('show');
            document.querySelector('.header').classList.remove('with-update-banner');
            
            // Remember dismissal for this session (could extend to localStorage for persistence)
            sessionStorage.setItem('updateDismissed', updateInfo?.latestVersion || '');
        }
        
        function startPeriodicUpdateCheck() {
            // Check for updates every 6 hours
            updateCheckInterval = setInterval(checkForUpdates, 6 * 60 * 60 * 1000);
        }
        
        function stopPeriodicUpdateCheck() {
            if (updateCheckInterval) {
                clearInterval(updateCheckInterval);
                updateCheckInterval = null;
            }
        }
        
        // Update button event listeners
        viewReleaseBtn.addEventListener('click', async () => {
            if (updateInfo && updateInfo.releaseUrl) {
                try {
                    await ipcRenderer.invoke('open-release-page', updateInfo.releaseUrl);
                    log('Opened release page in browser');
                } catch (error) {
                    log(`Failed to open release page: ${error.message}`);
                }
            }
        });
        
        downloadUpdateBtn.addEventListener('click', async () => {
            if (updateInfo && updateInfo.releaseUrl) {
                try {
                    // Open the releases page where user can download
                    await ipcRenderer.invoke('open-release-page', updateInfo.releaseUrl);
                    log('Opened download page in browser');
                    
                    // Hide banner after user clicks download
                    hideUpdateBanner();
                } catch (error) {
                    log(`Failed to open download page: ${error.message}`);
                }
            }
        });
        
        dismissUpdateBtn.addEventListener('click', () => {
            hideUpdateBanner();
            log('Update notification dismissed');
        });

        // Initialize
        initializeApp().then(() => {
            runStartupCheck().then(() => {
                // Check for updates after app initialization
                setTimeout(() => {
                    // Only check if not dismissed this session
                    const dismissed = sessionStorage.getItem('updateDismissed');
                    if (!dismissed) {
                        checkForUpdates();
                    }
                }, 2000); // Wait 2 seconds after startup
                
                // Start periodic checks
                startPeriodicUpdateCheck();
            });
        });
    </script>
</body>
</html>
