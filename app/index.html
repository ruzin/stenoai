<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Steno Recorder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Window drag area - make the top portion draggable */
        .drag-area {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            -webkit-app-region: drag;
            z-index: 100;
            pointer-events: none; /* Allow clicks to pass through to content below */
        }
        
        /* Make interactive elements non-draggable */
        .no-drag, .btn, .session-input, .settings-btn, button, input, select, textarea {
            -webkit-app-region: no-drag;
            pointer-events: auto;
        }
        
        /* Header with record controls */
        .header {
            background: #111;
            border-bottom: 1px solid #333;
            padding: 36px 24px 16px 16px; /* More top padding, move content left */
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: padding-top 0.3s ease;
        }
        
        .header.with-update-banner {
            padding-top: 84px; /* Additional space when update banner is shown */
        }
        
        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .brand h1 {
            font-size: 20px;
            font-weight: 600;
            color: #fff;
        }
        
        .header-actions {
            display: flex;
            align-items: center;
        }
        
        .settings-btn {
            background: transparent;
            border: 1px solid #444;
            color: #ccc;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .settings-btn:hover {
            background: #333;
            border-color: #555;
            color: #fff;
        }
        
        .record-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .session-input {
            background: #222;
            border: 1px solid #444;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            min-width: 200px;
            outline: none;
        }
        
        .session-input:focus {
            border-color: #666;
            background: #333;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 16px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        
        .status-dot.ready { background: #22c55e; }
        .status-dot.recording { 
            background: #ef4444; 
            animation: pulse 1s infinite;
        }
        .status-dot.processing { 
            background: #f59e0b; 
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn:hover {
            background: #444;
            border-color: #666;
        }
        
        .btn-primary {
            background: #fff;
            color: #000;
            border-color: #fff;
        }
        
        .btn-primary:hover {
            background: #f5f5f5;
        }
        
        .btn-danger {
            background: #ef4444;
            border-color: #ef4444;
        }
        
        .btn-danger:hover {
            background: #dc2626;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: #111;
            border-left: 1px solid #333;
            transition: right 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        
        .settings-header {
            padding: 20px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .settings-header h2 {
            margin: 0;
            font-size: 18px;
            color: #fff;
        }
        
        .close-settings {
            background: none;
            border: none;
            color: #ccc;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .close-settings:hover {
            background: #333;
            color: #fff;
        }
        
        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .settings-section {
            margin-bottom: 32px;
        }
        
        .settings-section h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #fff;
        }
        
        .settings-section h4 {
            margin: 16px 0 8px 0;
            font-size: 14px;
            color: #ccc;
        }
        
        .settings-section p {
            margin: 0 0 16px 0;
            color: #aaa;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .setup-info ul {
            margin: 16px 0;
            padding-left: 20px;
            color: #ccc;
        }
        
        .setup-info li {
            margin-bottom: 4px;
            font-size: 14px;
        }
        
        .prompt-viewer {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 16px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre-wrap;
            color: #ccc;
            max-height: 300px;
            overflow-y: auto;
        }
        
        /* Debug Panel */
        .debug-panel {
            position: fixed;
            top: 0;
            right: -500px;
            width: 500px;
            height: 100vh;
            background: #0a0a0a;
            border-left: 1px solid #333;
            transition: right 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        
        .debug-header {
            padding: 20px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #111;
        }
        
        .debug-header h2 {
            margin: 0;
            font-size: 18px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .debug-console {
            flex: 1;
            background: #000;
            color: #a0a0a0;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 11px;
            line-height: 1.4;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .debug-console::-webkit-scrollbar {
            width: 8px;
        }
        
        .debug-console::-webkit-scrollbar-track {
            background: #111;
        }
        
        .debug-console::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        
        .debug-console::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Model list scrollbar */
        #model-list::-webkit-scrollbar {
            width: 8px;
        }

        #model-list::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }

        #model-list::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        #model-list::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Main content area */
        .main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        /* Sidebar with meetings list */
        .sidebar {
            width: 320px;
            background: #111;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #333;
        }
        
        .sidebar-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .sidebar-header h2 {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
        }
        
        
        .search-input {
            background: #222;
            border: 1px solid #444;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            width: 100%;
            outline: none;
            margin: 12px 0 8px 0;
        }
        
        .search-input:focus {
            border-color: #666;
            background: #333;
        }
        
        .sidebar-header p {
            font-size: 14px;
            color: #888;
        }
        
        .meetings-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }
        
        .meeting-item {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .meeting-delete {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #444;
            border: none;
            color: #999;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
        }
        
        .meeting-item:hover .meeting-delete {
            opacity: 1;
        }
        
        .meeting-delete:hover {
            background: #ef4444;
            color: #fff;
        }
        
        .meeting-item:hover {
            background: #222;
            border-color: #444;
        }
        
        .meeting-item.active {
            background: #333;
            border-color: #555;
        }
        
        .meeting-item.processing {
            background: #1a1a1a;
            border-color: #f59e0b;
            opacity: 0.7;
            position: relative;
        }
        
        .meeting-item.processing .processing-overlay {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 4px;
            padding: 4px 8px;
        }
        
        .processing-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #f59e0b;
            font-size: 12px;
            font-weight: 500;
        }
        
        .processing-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #333;
            border-top: 2px solid #f59e0b;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .meeting-item h3 {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 6px;
            line-height: 1.3;
        }
        
        .meeting-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .meeting-date {
            font-size: 12px;
            color: #888;
        }
        
        .meeting-duration {
            font-size: 12px;
            color: #666;
            background: #222;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .meeting-preview {
            font-size: 13px;
            color: #aaa;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        /* Main content area */
        .content {
            flex: 1;
            background: #000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .content-empty {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            flex-direction: column;
            color: #666;
        }
        
        .content-empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        .content-empty h3 {
            font-size: 18px;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .content-empty p {
            font-size: 14px;
            color: #888;
        }
        
        /* Meeting detail view */
        .meeting-detail {
            padding: 32px;
            height: 100%;
            overflow-y: auto;
            display: none;
        }
        
        .meeting-detail.show {
            display: block;
        }
        
        .meeting-header {
            margin-bottom: 32px;
            padding-bottom: 24px;
            border-bottom: 1px solid #333;
        }
        
        .meeting-header-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }
        
        .meeting-title {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            margin: 0;
            flex: 1;
        }
        
        .reprocess-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 16px;
            flex-shrink: 0;
        }
        
        .reprocess-btn:hover {
            background: #444;
        }
        
        .reprocess-btn:active {
            transform: translateY(0);
        }
        
        .reprocess-btn:disabled {
            background: #333;
            color: #999;
            border-color: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        .reprocess-btn.processing {
            background: #FF9800;
            color: #fff;
            border-color: #FF9800;
        }
        
        .reprocess-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .transcript-container {
            position: relative;
        }
        
        .copy-transcript-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 6px;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-transcript-btn:hover {
            background: #444;
            opacity: 1;
            transform: translateY(-1px);
        }
        
        .copy-transcript-btn:active {
            transform: translateY(0);
        }
        
        .copy-transcript-btn.copied {
            background: #4CAF50;
            border-color: #4CAF50;
            opacity: 1;
        }

        .copy-notes-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
        }

        .copy-notes-btn:hover {
            background: #444;
            border-color: #666;
        }

        .copy-notes-btn:active {
            transform: translateY(1px);
        }

        .copy-notes-btn.copied {
            background: #4CAF50;
            border-color: #4CAF50;
        }

        .meeting-title-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 0;
            max-width: fit-content;
        }

        .meeting-title {
            margin: 0;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 600px;
        }

        .meeting-title-input {
            background: #222;
            border: 1px solid #666;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 24px;
            font-weight: 600;
            outline: none;
            flex: 1;
        }

        .meeting-title-input:focus {
            border-color: #888;
            background: #333;
        }

        .edit-title-btn {
            background: transparent;
            border: 1px solid #555;
            color: #888;
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
        }

        .meeting-title-container:hover .edit-title-btn {
            opacity: 1;
        }

        .edit-title-btn:hover {
            background: #333;
            border-color: #666;
            color: #fff;
        }

        .title-edit-actions {
            display: flex;
            gap: 8px;
        }

        .save-title-btn, .cancel-title-btn {
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
            border: 1px solid;
        }

        .save-title-btn {
            background: #4CAF50;
            border-color: #4CAF50;
            color: #fff;
        }

        .save-title-btn:hover {
            background: #45a049;
        }

        .cancel-title-btn {
            background: transparent;
            border-color: #555;
            color: #888;
        }

        .cancel-title-btn:hover {
            background: #333;
            color: #fff;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .meeting-info {
            display: flex;
            gap: 24px;
            align-items: center;
            color: #888;
            font-size: 14px;
        }
        
        .meeting-section {
            margin-bottom: 32px;
        }
        
        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section-content {
            color: #ccc;
            line-height: 1.6;
        }
        
        .key-points-list {
            list-style: none;
            padding: 0;
        }
        
        .key-points-list li {
            padding: 8px 0;
            padding-left: 20px;
            position: relative;
            color: #ccc;
            line-height: 1.5;
        }
        
        .key-points-list li:before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #666;
            font-weight: bold;
        }

        .action-items-list {
            list-style: none;
            padding: 0;
        }
        
        .action-items-list li {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            color: #ccc;
            line-height: 1.5;
        }
        
        /* Transcript section */
        .transcript-content {
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #ddd;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        
        /* File drop area */
        .drop-zone {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .drop-zone.active {
            display: flex;
        }
        
        .drop-message {
            text-align: center;
            color: #fff;
            font-size: 24px;
            font-weight: 600;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #111;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }
        
        /* Update Banner */
        .update-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #4F46E5, #7C3AED);
            color: white;
            padding: 12px 20px;
            display: none;
            align-items: center;
            justify-content: space-between;
            z-index: 1500;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes slideInFromBottom {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes slideOutToBottom {
            from {
                transform: translateY(0);
                opacity: 1;
            }
            to {
                transform: translateY(100%);
                opacity: 0;
            }
        }

        .update-banner.show {
            display: flex;
        }
        
        .update-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .update-icon {
            font-size: 20px;
            animation: pulse 2s infinite;
        }
        
        .update-text {
            font-size: 14px;
        }
        
        .update-text .version {
            font-weight: 600;
        }
        
        .update-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .update-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .update-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .update-btn.primary {
            background: white;
            color: #4F46E5;
            font-weight: 600;
        }
        
        .update-btn.primary:hover {
            background: #f3f4f6;
        }
        
        .dismiss-update {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            border-radius: 2px;
            transition: color 0.2s;
        }
        
        .dismiss-update:hover {
            color: white;
        }

        /* Setup Modal */
        .setup-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .setup-content {
            background: #111;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 32px;
            width: 600px;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .setup-header {
            text-align: center;
            margin-bottom: 32px;
        }
        
        .setup-header .btn-primary {
            margin-top: 20px;
            font-size: 16px;
            padding: 12px 24px;
        }
        
        .setup-header h2 {
            font-size: 24px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
        }
        
        .setup-header p {
            font-size: 16px;
            color: #888;
        }
        
        .setup-steps {
            margin-bottom: 32px;
        }
        
        .setup-step {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px;
            margin-bottom: 12px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .setup-step.active {
            border-color: #555;
            background: #222;
        }
        
        .setup-step.completed {
            border-color: #22c55e;
            background: #0f1f0f;
        }
        
        .setup-step.failed {
            border-color: #ef4444;
            background: #1f0f0f;
        }
        
        .step-icon {
            font-size: 24px;
            width: 40px;
            text-align: center;
        }
        
        .step-content {
            flex: 1;
        }
        
        .step-content h3 {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .step-content p {
            font-size: 14px;
            color: #888;
            margin-bottom: 8px;
        }
        
        .step-status {
            font-size: 13px;
            color: #666;
            font-weight: 500;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #f59e0b;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        
        .setup-step.completed .progress-fill {
            background: #22c55e;
            width: 100%;
        }
        
        .setup-step.active .step-status {
            color: #f59e0b;
        }
        
        .setup-step.completed .step-status {
            color: #22c55e;
        }
        
        .setup-step.failed .step-status {
            color: #ef4444;
        }
        
        .setup-actions {
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }
        
        .setup-actions .btn {
            flex: 1;
        }
    </style>
</head>
<body>
    <!-- Window drag area -->
    <div class="drag-area"></div>
    
    <!-- Update Banner -->
    <div class="update-banner" id="update-banner">
        <div class="update-info">
            <div class="update-icon">üöÄ</div>
            <div class="update-text">
                <span>New version available: </span>
                <span class="version" id="update-version">v0.0.17</span>
            </div>
        </div>
        <div class="update-actions">
            <button class="update-btn" id="view-release-btn">View Release</button>
            <button class="update-btn primary" id="download-update-btn">Download Update</button>
            <button class="dismiss-update" id="dismiss-update-btn" title="Dismiss">‚úï</button>
        </div>
    </div>

    <!-- Header with recording controls -->
    <div class="header">
        <div class="brand">
            <svg width="28" height="28" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect width="32" height="32" rx="8" fill="#1e293b"/>
                <rect width="30" height="30" x="1" y="1" rx="7" stroke="rgba(255,255,255,0.1)"/>
                <path d="M16 10c-1.1 0-2 .9-2 2v4c0 1.1.9 2 2 2s2-.9 2-2v-4c0-1.1-.9-2-2-2z" fill="white"/>
                <path d="M12 15v1c0 2.2 1.8 4 4 4s4-1.8 4-4v-1h1v1c0 2.7-1.9 4.9-4.5 5.4v1.6h2v1h-5v-1h2v-1.6c-2.6-.5-4.5-2.7-4.5-5.4v-1h1z" fill="white"/>
            </svg>
            <h1>StenoAI</h1>
        </div>
        
        <div class="record-controls">
            <div class="status">
                <div class="status-dot ready" id="status-dot"></div>
                <span id="status-text">Ready</span>
            </div>
            
            <input type="text" class="session-input" id="session-name" placeholder="Enter meeting name..." value="Meeting">
            
            <button class="btn btn-primary" id="start-btn">
                <span>‚óè</span> Start Recording
            </button>
            
            <button class="btn btn-danger" id="stop-btn" style="display: none;">
                <span>‚ñ†</span> Stop Recording
            </button>

            <button class="btn" id="pause-btn" style="display: none;">
                <span>‚è∏</span> Pause
            </button>
        </div>
        
        <div class="header-actions">
            <button class="settings-btn" id="debug-btn" title="Debug Logs" style="margin-right: 8px;">üî®</button>
            <button class="settings-btn" id="ai-settings-btn" title="AI Settings" style="margin-right: 8px;">üß†</button>
            <button class="settings-btn" id="settings-btn" title="Settings">‚öôÔ∏è</button>
        </div>
    </div>

    <!-- Main content area -->
    <div class="main">
        <!-- Sidebar with meetings -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">
                    <h2>Meetings</h2>
                </div>
                <input type="text" class="search-input" id="search-input" placeholder="Search meetings...">
            </div>
            
            <div class="meetings-list" id="meetings-list">
                <!-- Meetings will be loaded here -->
            </div>
        </div>

        <!-- Main content -->
        <div class="content">
            <!-- Empty state -->
            <div class="content-empty" id="empty-state">
                <div class="content-empty-icon">üìù</div>
                <h3>No meeting selected</h3>
                <p>Select a meeting from the sidebar or record a new one</p>
            </div>

            <!-- Meeting detail view -->
            <div class="meeting-detail" id="meeting-detail">
                <div class="meeting-header">
                    <div class="meeting-header-top">
                        <div class="meeting-title-container">
                            <h1 class="meeting-title" id="detail-title">Meeting Title</h1>
                            <button class="edit-title-btn" id="edit-title-btn" title="Edit meeting name">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                        </div>
                        <div style="display: flex; gap: 0px;">
                            <button class="copy-notes-btn" id="copy-notes-btn" title="Copy all meeting notes to clipboard">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                            </button>
                            <button class="reprocess-btn" id="reprocess-btn" title="Reprocess current meeting if analysis failed or needs improvement">
                                Reprocess
                            </button>
                        </div>
                    </div>
                    <div class="meeting-info">
                        <span id="detail-date">Date</span>
                        <span id="detail-duration">Duration</span>
                    </div>
                </div>

                <div class="meeting-section">
                    <h2 class="section-title">
                        <span>üìã</span> Summary
                    </h2>
                    <div class="section-content" id="detail-summary">
                        Meeting summary will appear here...
                    </div>
                </div>

                <div class="meeting-section">
                    <h2 class="section-title">
                        <span>üë•</span> Participants
                    </h2>
                    <div class="section-content" id="detail-participants">
                        <!-- Participants will be loaded here -->
                    </div>
                </div>

                <div class="meeting-section" id="discussion-areas-section">
                    <h2 class="section-title">
                        <span>üí¨</span> Key Topics
                    </h2>
                    <div class="discussion-areas-container" id="detail-discussion-areas">
                        <!-- Key topics will be loaded here -->
                    </div>
                </div>

                <div class="meeting-section">
                    <h2 class="section-title">
                        <span>üîë</span> Key Points
                    </h2>
                    <ul class="key-points-list" id="detail-key-points">
                        <!-- Key points will be loaded here -->
                    </ul>
                </div>

                <div class="meeting-section">
                    <h2 class="section-title">
                        <span>‚úÖ</span> Action Items
                    </h2>
                    <ul class="action-items-list" id="detail-action-items">
                        <!-- Action items will be loaded here -->
                    </ul>
                </div>

                <div class="meeting-section">
                    <h2 class="section-title">
                        <span>üìÑ</span> Full Transcript
                    </h2>
                    <div class="transcript-container">
                        <div class="transcript-content" id="detail-transcript">
                            Full transcript will appear here...
                        </div>
                        <button class="copy-transcript-btn" id="copy-transcript-btn" title="Copy transcript to clipboard">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Drop zone for files -->
    <div class="drop-zone" id="drop-zone">
        <div class="drop-message">
            Drop audio file to process
        </div>
    </div>

    <!-- Setup overlay -->
    <div class="setup-modal" id="setup-overlay" style="display: none;">
        <div class="setup-content">
            <div class="setup-header">
                <h2>üöÄ Welcome to StenoAI</h2>
                <p>Setting up your system for meeting transcription...</p>
                <p style="font-size: 14px; color: #aaa; margin-top: 12px;">üí° Scroll down to see logs</p>
            </div>

            <div class="setup-steps" id="setup-steps">
                <div class="setup-step" id="step-microphone">
                    <div class="step-icon">üé§</div>
                    <div class="step-content">
                        <h3>Microphone Access</h3>
                        <p>Grant microphone permission for meeting recording</p>
                        <div class="step-status" id="microphone-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="microphone-progress"></div>
                        </div>
                    </div>
                </div>

                <div class="setup-step" id="step-system">
                    <div class="step-icon">üñ•Ô∏è</div>
                    <div class="step-content">
                        <h3>System Check</h3>
                        <p>Checking Python and system requirements...</p>
                        <div class="step-status" id="system-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="system-progress"></div>
                        </div>
                    </div>
                </div>

                
                <div class="setup-step" id="step-python">
                    <div class="step-icon">üêç</div>
                    <div class="step-content">
                        <h3>Python Dependencies</h3>
                        <p>Installing audio libraries</p>
                        <div class="step-status" id="python-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="python-progress"></div>
                        </div>
                    </div>
                </div>
                
                <div class="setup-step" id="step-whisper">
                    <div class="step-icon">üé§</div>
                    <div class="step-content">
                        <h3>Install Whisper</h3>
                        <p>OpenAI's speech recognition engine</p>
                        <div class="step-status" id="whisper-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="whisper-progress"></div>
                        </div>
                    </div>
                </div>
                
                <div class="setup-step" id="step-ollama">
                    <div class="step-icon">üß†</div>
                    <div class="step-content">
                        <h3>Install Ollama + AI Model</h3>
                        <p>Homebrew (if needed) ‚Üí Ollama ‚Üí Llama 3.2 model (~2GB)</p>
                        <div class="step-status" id="ollama-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="ollama-progress"></div>
                        </div>
                    </div>
                </div>
                
                <div class="setup-step" id="step-ffmpeg">
                    <div class="step-icon">üé•</div>
                    <div class="step-content">
                        <h3>Install ffmpeg</h3>
                        <p>Audio/video processing toolkit for advanced audio handling</p>
                        <div class="step-status" id="ffmpeg-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="ffmpeg-progress"></div>
                        </div>
                    </div>
                </div>
                
                <div class="setup-step" id="step-test">
                    <div class="step-icon">‚úÖ</div>
                    <div class="step-content">
                        <h3>Test System</h3>
                        <p>Verifying everything works</p>
                        <div class="step-status" id="test-status">Pending...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="test-progress"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="setup-debug" style="margin: 24px 0;">
                <h3 style="margin-bottom: 12px; display: flex; align-items: center; gap: 8px; font-size: 16px;">
                    <span>üêõ Debug Console</span>
                    <button onclick="toggleDebugConsole()" style="background: none; border: 1px solid #444; color: #888; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">Toggle</button>
                </h3>
                <div id="debug-console" style="background: #000; border: 1px solid #333; border-radius: 6px; padding: 12px; font-family: 'Monaco', 'Menlo', monospace; font-size: 11px; line-height: 1.4; color: #a0a0a0; height: 200px; overflow-y: auto; white-space: pre-wrap;">Welcome to StenoAI Setup Debug Console
Commands and output will appear here...

</div>
            </div>

            <div class="setup-actions">
                <button class="btn btn-primary" id="setup-auto-start">Begin First-Time Setup</button>
                <button class="btn btn-primary" id="setup-continue" style="display: none;">Continue to App</button>
            </div>
        </div>
    </div>

    <!-- Settings Panel (slides in from right) -->
    <div class="settings-panel" id="settings-panel">
        <div class="settings-header">
            <h2>‚öôÔ∏è Settings</h2>
            <button class="close-settings" onclick="toggleSettings()">‚úï</button>
        </div>
        
        <div class="settings-content">
            <div class="settings-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h3>üîß Setup Wizard</h3>
                    <span style="font-size: 12px; color: #888;">Version: <span id="app-version">Loading...</span></span>
                </div>
                <p>Run the setup process again to reinstall dependencies or fix configuration issues.</p>
                
                <div class="setup-info">
                    <ul>
                        <li>Python virtual environment</li>
                        <li>Audio recording libraries</li>
                        <li>Whisper speech recognition</li>
                        <li>Ollama AI service and models</li>
                        <li>ffmpeg audio processing toolkit</li>
                    </ul>
                </div>
                
                <button class="btn btn-primary" id="run-setup-btn" onclick="runSetupFromSettings()">
                    Run Setup Wizard
                </button>
            </div>

            <div class="settings-section">
                <h3>üîî Notifications</h3>

                <div style="margin-top: 15px;">
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                        <input type="checkbox" id="notifications-toggle" style="width: 18px; height: 18px; cursor: pointer;">
                        <span style="color: #ccc;">Show desktop notifications for meeting completions</span>
                    </label>
                    <p style="font-size: 12px; color: #888; margin-top: 8px; margin-left: 28px;">
                        Get notified when your meetings finish processing (even when the app is in the background)
                    </p>
                </div>
            </div>

            <div class="settings-section">
                <h3>üõ†Ô∏è System Recovery</h3>
                <p>Tools to recover from stuck recordings or processing issues.</p>

                <button class="btn" id="clear-state-btn" onclick="clearSystemState()">
                    Clear Recording State
                </button>

            </div>
            
            <div class="settings-section">
                <h3>üîÑ Updates</h3>
                <p>Check for the latest version of StenoAI. After installing, if macOS shows a security warning, go to <strong>System Settings > Privacy & Security</strong>, scroll down and click <strong>'Open Anyway'</strong>.</p>
                
                <button class="btn" id="test-update-btn" onclick="testUpdateCheck()">
                    Check for Updates
                </button>

            </div>
        </div>
    </div>

    <!-- Debug Panel (slides in from right) -->
    <div class="debug-panel" id="debug-panel">
        <div class="debug-header">
            <h2>üî® Debug Logs</h2>
            <button class="close-settings" onclick="toggleDebug()">‚úï</button>
        </div>

        <div class="debug-console" id="debug-console-panel">StenoAI Debug Console
Session started - waiting for activity...

</div>
    </div>

    <!-- AI Settings Panel (slides in from right) -->
    <div class="settings-panel" id="ai-settings-panel">
        <div class="settings-header">
            <h2>üß† AI Settings</h2>
            <button class="close-settings" onclick="toggleAISettings()">‚úï</button>
        </div>

        <div class="settings-content">
            <div class="settings-section">
                <h3>ü§ñ Model Selection</h3>
                <p>Choose which AI model to use for meeting summarization. Larger models provide better quality but take longer to process.</p>

                <div style="margin-top: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 500;">Current Model:</label>
                    <div id="current-model-display" style="padding: 10px; background: #2a2a2a; border-radius: 4px; margin-bottom: 15px;">
                        <span style="font-family: Monaco, monospace; color: #4CAF50;">Loading...</span>
                    </div>

                    <label style="display: block; margin-bottom: 8px; font-weight: 500;">Select Model:</label>
                    <div id="model-list" style="display: flex; flex-direction: column; gap: 10px; max-height: 450px; overflow-y: auto; padding-right: 5px;">
                        Loading models...
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h3>üß† AI Prompts</h3>
                <p>View the prompts used for meeting summarization and analysis.</p>

                <h4>Summarization Prompt</h4>
                <div class="prompt-viewer" id="summarization-prompt">
                    Loading prompt...
                </div>
            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');
        
        // UI Elements
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const sessionNameInput = document.getElementById('session-name');
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const debugBtn = document.getElementById('debug-btn');
        const aiSettingsBtn = document.getElementById('ai-settings-btn');
        const meetingsList = document.getElementById('meetings-list');
        const emptyState = document.getElementById('empty-state');
        const meetingDetail = document.getElementById('meeting-detail');
        const dropZone = document.getElementById('drop-zone');
        
        // Update elements
        const updateBanner = document.getElementById('update-banner');
        const updateVersion = document.getElementById('update-version');
        const viewReleaseBtn = document.getElementById('view-release-btn');
        const downloadUpdateBtn = document.getElementById('download-update-btn');
        const dismissUpdateBtn = document.getElementById('dismiss-update-btn');
        
        // Detail elements
        const detailTitle = document.getElementById('detail-title');
        const detailDate = document.getElementById('detail-date');
        const detailDuration = document.getElementById('detail-duration');
        const detailSummary = document.getElementById('detail-summary');
        const detailParticipants = document.getElementById('detail-participants');
        const detailKeyPoints = document.getElementById('detail-key-points');
        const detailActionItems = document.getElementById('detail-action-items');
        const detailTranscript = document.getElementById('detail-transcript');
        const reprocessBtn = document.getElementById('reprocess-btn');
        const copyTranscriptBtn = document.getElementById('copy-transcript-btn');
        const copyNotesBtn = document.getElementById('copy-notes-btn');
        const editTitleBtn = document.getElementById('edit-title-btn');

        // Setup elements
        const setupOverlay = document.getElementById('setup-overlay');
        const setupAutoStart = document.getElementById('setup-auto-start');
        const setupContinue = document.getElementById('setup-continue');
        
        let uiState = 'ready'; // ready, recording, processing, setup-needed
        let meetings = [];
        let filteredMeetings = [];
        let selectedMeeting = null;
        let recordingProcess = null;
        let statusCheckInterval = null;
        let processingMeeting = null; // Track which meeting is currently being reprocessed
        let searchQuery = '';
        let recordingStartTime = null;
        let recordingTimer = null;
        let pausedElapsedTime = 0; // Track elapsed time when paused
        let processingMeetings = new Set();
        let meetingsLastLoaded = 0; // Cache timestamp
        
        // Update checking variables
        let updateInfo = null;
        let updateCheckInterval = null;
        
        // Utility functions
        function log(message) {
            console.log(`[${new Date().toLocaleTimeString()}] ${message}`);
        }
        
        function generateMeetingHash() {
            // Generate short hash for meeting names
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }
        
        function setStatus(status, message) {
            statusDot.className = `status-dot ${status}`;
            statusText.textContent = message;
            log(`Status: ${message}`);
        }
        
        function startRecordingTimer(resume = false) {
            // If resuming, adjust start time to account for already elapsed time
            if (resume && pausedElapsedTime > 0) {
                recordingStartTime = Date.now() - (pausedElapsedTime * 1000);
            } else {
                recordingStartTime = Date.now();
                pausedElapsedTime = 0;
            }
            recordingTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                setStatus('recording', `Recording... ${timeStr}`);
            }, 1000);
        }

        function pauseRecordingTimer() {
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
            // Save elapsed time before pausing
            if (recordingStartTime) {
                pausedElapsedTime = Math.floor((Date.now() - recordingStartTime) / 1000);
            }
        }

        function stopRecordingTimer() {
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
            recordingStartTime = null;
            pausedElapsedTime = 0;
        }
        
        function setUIState(state) {
            uiState = state;
            log(`UI State: ${state}`);

            // Update UI elements based on state
            switch(state) {
                case 'ready':
                    startBtn.style.display = 'inline-flex';
                    stopBtn.style.display = 'none';
                    pauseBtn.style.display = 'none';
                    startBtn.disabled = false;
                    sessionNameInput.disabled = false;
                    stopRecordingTimer();
                    setStatus('ready', 'Ready');
                    break;

                case 'recording':
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-flex';
                    pauseBtn.style.display = 'inline-flex';
                    pauseBtn.innerHTML = '<span>‚è∏</span> Pause';
                    startBtn.disabled = true;
                    sessionNameInput.disabled = true;
                    stopBtn.disabled = false;
                    pauseBtn.disabled = false;
                    // Check if resuming from paused state (pausedElapsedTime > 0)
                    startRecordingTimer(pausedElapsedTime > 0);
                    break;

                case 'paused':
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-flex';
                    pauseBtn.style.display = 'inline-flex';
                    pauseBtn.innerHTML = '<span>‚ñ∂</span> Resume';
                    startBtn.disabled = true;
                    sessionNameInput.disabled = true;
                    stopBtn.disabled = false;
                    pauseBtn.disabled = false;
                    pauseRecordingTimer();
                    // Show paused status with the frozen time
                    const minutes = Math.floor(pausedElapsedTime / 60);
                    const seconds = pausedElapsedTime % 60;
                    const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    setStatus('recording', `Paused ${timeStr}`);
                    break;

                case 'processing':
                    startBtn.style.display = 'inline-flex';
                    stopBtn.style.display = 'none';
                    pauseBtn.style.display = 'none';
                    startBtn.disabled = true;
                    sessionNameInput.disabled = true;
                    stopRecordingTimer();
                    setStatus('processing', 'Processing...');
                    break;
            }
        }
        
        function startStatusMonitoring() {
            // Only check status when we think we're recording
            if (statusCheckInterval) clearInterval(statusCheckInterval);
            
            statusCheckInterval = setInterval(async () => {
                if (uiState === 'recording') {
                    try {
                        // Check if microphone permission was revoked during recording
                        const micResult = await ipcRenderer.invoke('check-microphone-permission');
                        if (!micResult.success || micResult.status !== 'granted') {
                            log('üö´ Microphone permission revoked during recording - stopping');
                            alert('‚ùå Microphone access was revoked! Recording stopped.\n\nPlease grant microphone permission to continue recording.');
                            setUIState('ready');
                            stopStatusMonitoring();
                            showSetupOverlay([]);
                            return;
                        }
                        
                        const result = await ipcRenderer.invoke('get-status');
                        if (result.success && !result.status.includes('RECORDING')) {
                            // Backend says not recording but UI thinks it is - sync up
                            log('Backend/UI state mismatch - syncing');
                            setUIState('ready');
                            stopStatusMonitoring();
                        }
                    } catch (error) {
                        log(`Status check failed: ${error.message}`);
                    }
                }
            }, 10000); // Check every 10 seconds only when recording
        }
        
        function stopStatusMonitoring() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
                statusCheckInterval = null;
            }
        }
        
        
        function formatDate(dateString) {
            if (!dateString) return 'Unknown date';
            try {
                return new Date(dateString).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch {
                return 'Unknown date';
            }
        }
        
        function formatDuration(startTime, endTime) {
            if (!startTime || !endTime) return 'Unknown';
            try {
                const start = new Date(startTime);
                const end = new Date(endTime);
                const minutes = Math.round((end - start) / 60000);
                return `${minutes} min`;
            } catch {
                return 'Unknown';
            }
        }
        
        // Delete meeting function
        async function deleteMeeting(index, event) {
            event.stopPropagation(); // Prevent selecting the meeting
            
            const meeting = filteredMeetings[index];
            if (!meeting) return;
            
            const confirmed = confirm(`Delete meeting "${meeting.session_info?.name || 'Untitled Meeting'}"?\n\nThis will delete the transcript, summary, and all associated files.`);
            if (!confirmed) return;
            
            try {
                // Pass the entire meeting object to the backend
                const result = await ipcRenderer.invoke('delete-meeting', meeting);
                
                if (result.success) {
                    log(`Meeting deleted: ${result.message}`);
                    
                    // Remove meeting from local arrays
                    meetings = meetings.filter(m => m !== meeting);
                    filteredMeetings = filteredMeetings.filter(m => m !== meeting);
                    
                    // Re-render the meetings list
                    filterMeetings();
                    
                    // Clear selected meeting if it was deleted
                    if (selectedMeeting === meeting) {
                        selectedMeeting = null;
                        emptyState.style.display = 'flex';
                        meetingDetail.classList.remove('show');
                    }
                } else {
                    log(`Failed to delete meeting: ${result.error}`);
                    alert(`Failed to delete meeting: ${result.error}`);
                }
            } catch (error) {
                log(`Error deleting meeting: ${error.message}`);
                alert(`Error deleting meeting: ${error.message}`);
            }
        }
        
        // Filter meetings based on search query
        function filterMeetings() {
            if (!searchQuery.trim()) {
                filteredMeetings = [...meetings];
            } else {
                const query = searchQuery.toLowerCase();
                filteredMeetings = meetings.filter(meeting => {
                    const name = (meeting.session_info?.name || '').toLowerCase();
                    const summary = (meeting.summary || '').toLowerCase();
                    const keyPoints = (meeting.key_points || []).join(' ').toLowerCase();
                    const actionItems = (meeting.action_items || []).join(' ').toLowerCase();
                    
                    return name.includes(query) || 
                           summary.includes(query) || 
                           keyPoints.includes(query) || 
                           actionItems.includes(query);
                });
            }
            renderMeetingsList();
        }
        
        // Load meetings from backend with caching
        async function loadMeetings(forceRefresh = false) {
            const now = Date.now();
            
            // Use cache if data is less than 30 seconds old and not forced refresh
            if (!forceRefresh && meetings.length > 0 && (now - meetingsLastLoaded) < 30000) {
                log('Using cached meetings data');
                filterMeetings();
                return;
            }
            
            // Show loading state only if we don't have cached data
            if (meetings.length === 0) {
                meetingsList.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #666;">
                        <div style="font-size: 24px; margin-bottom: 8px;">‚ü≥</div>
                        <p>Loading meetings...</p>
                    </div>
                `;
            }
            
            try {
                const result = await ipcRenderer.invoke('list-meetings');
                if (result.success) {
                    meetings = result.meetings || [];
                    meetingsLastLoaded = now;
                    filterMeetings(); // Apply current search filter
                    log(`Loaded ${meetings.length} meetings`);
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                log(`Failed to load meetings: ${error.message}`);
                // Only show error if we don't have cached data
                if (meetings.length === 0) {
                    meetingsList.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #666;">
                            <div style="font-size: 24px; margin-bottom: 8px;">‚ö†Ô∏è</div>
                            <p>Failed to load meetings</p>
                            <p style="font-size: 12px; margin-top: 4px;">Using cached data if available</p>
                        </div>
                    `;
                } else {
                    // We have cached data, just log the error
                    log('Using cached meetings data due to load failure');
                    filterMeetings();
                }
            }
        }
        
        // Render meetings list
        function renderMeetingsList() {
            if (filteredMeetings.length === 0 && searchQuery.trim()) {
                meetingsList.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #666;">
                        <div style="font-size: 24px; margin-bottom: 8px;">üîç</div>
                        <p>No meetings match "${searchQuery}"</p>
                        <p style="font-size: 12px; margin-top: 4px;">Try a different search term</p>
                    </div>
                `;
                return;
            }
            
            if (meetings.length === 0) {
                meetingsList.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #666;">
                        <div style="font-size: 24px; margin-bottom: 8px;">üéôÔ∏è</div>
                        <p>No meetings recorded yet</p>
                        <p style="font-size: 12px; margin-top: 4px;">Start recording to see your meetings here</p>
                    </div>
                `;
                return;
            }
            
            meetingsList.innerHTML = filteredMeetings.map((meeting, index) => {
                const isProcessing = processingMeetings.has(meeting.session_info?.name);
                return `
                <div class="meeting-item ${isProcessing ? 'processing' : ''}" data-index="${index}">
                    ${isProcessing ? '<div class="processing-overlay"><div class="processing-indicator"><div class="processing-spinner"></div>Processing...</div></div>' : ''}
                    <button class="meeting-delete" onclick="deleteMeeting(${index}, event)" title="Delete meeting">‚úï</button>
                    <h3>${meeting.session_info?.name || 'Untitled Meeting'}</h3>
                    <div class="meeting-meta">
                        <span class="meeting-date">${formatDate(meeting.session_info?.processed_at)}</span>
                    </div>
                    <div class="meeting-preview">
                        ${(meeting.summary || 'No summary available').substring(0, 100)}...
                    </div>
                </div>
                `;
            }).join('');
            
            // Add click handlers
            document.querySelectorAll('.meeting-item').forEach(item => {
                item.addEventListener('click', () => {
                    const index = parseInt(item.dataset.index);
                    selectMeeting(index);
                });
            });
        }
        
        // Select and display meeting details
        function selectMeeting(index) {
            selectedMeeting = filteredMeetings[index];
            if (!selectedMeeting) return;
            
            // Update active state
            document.querySelectorAll('.meeting-item').forEach((item, i) => {
                item.classList.toggle('active', i === index);
            });
            
            // Show meeting details
            emptyState.style.display = 'none';
            meetingDetail.classList.add('show');
            
            // Populate details
            detailTitle.textContent = selectedMeeting.session_info?.name || 'Untitled Meeting';
            detailDate.textContent = formatDate(selectedMeeting.session_info?.processed_at);
            const durationText = selectedMeeting.session_info?.duration_seconds ? 
                (() => {
                    const totalSecs = selectedMeeting.session_info.duration_seconds;
                    const hours = Math.floor(totalSecs / 3600);
                    const mins = Math.floor((totalSecs % 3600) / 60);
                    const secs = totalSecs % 60;
                    
                    if (hours > 0) return `üïí Meeting Duration: ${hours}h ${mins}m`;
                    if (mins > 0) return `üïí Meeting Duration: ${mins}m ${secs}s`;
                    return `üïí Meeting Duration: ${secs}s`;
                })() :
                (selectedMeeting.session_info?.duration_minutes ? 
                    `üïí Meeting Duration: ${selectedMeeting.session_info.duration_minutes} minutes` : 'üìÑ Processed');
            detailDuration.textContent = durationText;
            
            detailSummary.textContent = selectedMeeting.summary || 'No summary available';
            
            // Participants
            if (selectedMeeting.participants && selectedMeeting.participants.length > 0) {
                detailParticipants.textContent = selectedMeeting.participants.join(', ');
            } else {
                detailParticipants.innerHTML = '<span style="color: #666;">No participants identified</span>';
            }

            // Key topics
            const detailDiscussionAreas = document.getElementById('detail-discussion-areas');
            const discussionAreasSection = document.getElementById('discussion-areas-section');
            detailDiscussionAreas.innerHTML = '';
            if (selectedMeeting.discussion_areas && selectedMeeting.discussion_areas.length > 0) {
                discussionAreasSection.style.display = 'block';
                selectedMeeting.discussion_areas.forEach(area => {
                    const areaDiv = document.createElement('div');
                    areaDiv.style.marginBottom = '15px';
                    areaDiv.style.padding = '12px';
                    areaDiv.style.background = 'rgba(255, 255, 255, 0.03)';
                    areaDiv.style.borderRadius = '6px';
                    areaDiv.style.borderLeft = '3px solid rgba(99, 102, 241, 0.5)';

                    const title = document.createElement('h4');
                    title.textContent = area.title || 'Discussion Topic';
                    title.style.margin = '0 0 8px 0';
                    title.style.color = 'rgba(99, 102, 241, 1)';
                    title.style.fontSize = '14px';
                    title.style.fontWeight = '600';

                    const analysis = document.createElement('p');
                    analysis.textContent = area.analysis || '';
                    analysis.style.margin = '0';
                    analysis.style.color = '#ccc';
                    analysis.style.lineHeight = '1.5';

                    areaDiv.appendChild(title);
                    areaDiv.appendChild(analysis);
                    detailDiscussionAreas.appendChild(areaDiv);
                });
            } else {
                discussionAreasSection.style.display = 'none';
            }

            // Key points
            detailKeyPoints.innerHTML = '';
            if (selectedMeeting.key_points && selectedMeeting.key_points.length > 0) {
                selectedMeeting.key_points.forEach(point => {
                    const li = document.createElement('li');
                    li.textContent = point;
                    detailKeyPoints.appendChild(li);
                });
            } else {
                detailKeyPoints.innerHTML = '<li style="color: #666;">No key points identified</li>';
            }
            
            // Action items
            detailActionItems.innerHTML = '';
            if (selectedMeeting.action_items && selectedMeeting.action_items.length > 0) {
                selectedMeeting.action_items.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item;
                    detailActionItems.appendChild(li);
                });
            } else {
                detailActionItems.innerHTML = '<li style="color: #666;">No action items identified</li>';
            }
            
            // Transcript
            detailTranscript.textContent = selectedMeeting.transcript || 'No transcript available';
            
            // Set reprocess button state based on whether this meeting is currently processing
            const isCurrentlyProcessing = processingMeeting && processingMeeting.session_info?.summary_file === selectedMeeting.session_info?.summary_file;
            
            if (isCurrentlyProcessing) {
                // Restore processing state
                reprocessBtn.disabled = true;
                reprocessBtn.classList.add('processing');
                reprocessBtn.innerHTML = '<div class="reprocess-spinner"></div>Processing...';
            } else {
                // Normal state
                reprocessBtn.disabled = false;
                reprocessBtn.classList.remove('processing');
                reprocessBtn.innerHTML = 'Reprocess';
            }
            
            // TEMPORARY: Show reprocess button for all meetings (for testing)
            reprocessBtn.style.display = 'flex';
            
            /* ORIGINAL LOGIC (commented out for testing):
            // Show/hide reprocess button based on meeting quality
            const hasFailedSummary = (
                !selectedMeeting.summary || 
                selectedMeeting.summary.includes('No transcript was generated') ||
                selectedMeeting.summary.includes('detailed analysis failed') ||
                selectedMeeting.summary.includes('not fully supported') ||
                (selectedMeeting.overview && (
                    selectedMeeting.overview.includes('No transcript was generated') ||
                    selectedMeeting.overview.includes('detailed analysis failed') ||
                    selectedMeeting.overview.includes('not fully supported')
                ))
            );
            
            const hasNoParticipants = !selectedMeeting.participants || selectedMeeting.participants.length === 0;
            const hasNoKeyPoints = !selectedMeeting.key_points || selectedMeeting.key_points.length === 0;
            
            // Show reprocess button if meeting appears to have failed summarization
            if (hasFailedSummary || (hasNoParticipants && hasNoKeyPoints && selectedMeeting.transcript && selectedMeeting.transcript.length > 100)) {
                reprocessBtn.style.display = 'flex';
            } else {
                reprocessBtn.style.display = 'none';
            }
            */
        }
        
        
        // Manual start/stop recording functions
        startBtn.addEventListener('click', async () => {
            // Check microphone permission before allowing recording
            try {
                const micResult = await ipcRenderer.invoke('check-microphone-permission');
                if (!micResult.success || micResult.status !== 'granted') {
                    log('üö´ Cannot start recording - microphone permission denied');
                    
                    // Show clear error message
                    const micStatus = micResult.status || 'unknown';
                    alert(`‚ùå Recording blocked: Microphone permission is ${micStatus}.\n\nStenoAI requires microphone access to record meetings. Please grant permission and try again.`);
                    
                    // Force show setup wizard to fix the issue
                    showSetupOverlay([]);
                    return;
                }
            } catch (error) {
                log(`üö´ Failed to check microphone permission: ${error.message}`);
                alert('‚ùå Cannot verify microphone permission. Please ensure the app has proper access.');
                return;
            }
            
            // Generate session name if empty or use Meeting-HASH format
            let sessionName = sessionNameInput.value.trim();
            if (!sessionName || sessionName === 'Meeting') {
                sessionName = `Meeting-${generateMeetingHash()}`;
                sessionNameInput.value = sessionName;
            }
            
            log(`üéôÔ∏è Starting recording: ${sessionName}`);
            setUIState('recording');
            
            try {
                const result = await ipcRenderer.invoke('start-recording-ui', sessionName);
                if (result.success) {
                    log(`Recording started: ${result.message}`);
                    startStatusMonitoring();
                } else {
                    log(`Failed to start: ${result.error}`);
                    setUIState('ready');
                }
            } catch (error) {
                log(`üö´ Start error: ${error.message}`);
                setUIState('ready');
            }
        });
        
        stopBtn.addEventListener('click', async () => {
            log('‚èπÔ∏è Stopping recording...');
            setUIState('processing');
            stopStatusMonitoring();
            
            // Add current session to processing list immediately
            const currentSessionName = sessionNameInput.value.trim() || 'Meeting';
            processingMeetings.add(currentSessionName);
            
            // Add a temporary meeting entry to show processing
            const tempMeeting = {
                session_info: {
                    name: currentSessionName,
                    processed_at: new Date().toISOString(),
                    duration_seconds: null
                },
                summary: 'Pending...',
                key_points: [],
                action_items: [],
                transcript: ''
            };
            
            // Add to beginning of meetings array temporarily
            meetings.unshift(tempMeeting);
            filterMeetings(); // Update UI to show processing state
            
            try {
                const result = await ipcRenderer.invoke('stop-recording-ui');
                if (result.success) {
                    log(`Recording stopped: ${result.message}`);
                    log('üîÑ Processing audio - transcription and summarization running in background');
                    log('üí° Meeting list will refresh automatically when processing completes');
                    
                    // Return to ready state quickly so user can start another recording if needed
                    setTimeout(() => {
                        setUIState('ready');
                        sessionNameInput.value = 'Meeting';
                    }, 5000); // 5 seconds
                    
                } else {
                    log(`Failed to stop: ${result.error}`);
                    setUIState('ready');
                    processingMeetings.delete(currentSessionName);
                    renderMeetingsList();
                }
            } catch (error) {
                log(`üö´ Stop error: ${error.message}`);
                setUIState('ready');
                processingMeetings.delete(currentSessionName);
                renderMeetingsList();
            }
        });

        pauseBtn.addEventListener('click', async () => {
            if (uiState === 'recording') {
                // Pause recording
                log('‚è∏Ô∏è Pausing recording...');
                try {
                    const result = await ipcRenderer.invoke('pause-recording-ui');
                    if (result.success) {
                        setUIState('paused');
                    } else {
                        log(`Failed to pause: ${result.error}`);
                    }
                } catch (error) {
                    log(`üö´ Pause error: ${error.message}`);
                }
            } else if (uiState === 'paused') {
                // Resume recording
                log('‚ñ∂Ô∏è Resuming recording...');
                try {
                    const result = await ipcRenderer.invoke('resume-recording-ui');
                    if (result.success) {
                        setUIState('recording');
                    } else {
                        log(`Failed to resume: ${result.error}`);
                    }
                } catch (error) {
                    log(`üö´ Resume error: ${error.message}`);
                }
            }
        });

        // Search functionality
        const searchInput = document.getElementById('search-input');
        searchInput.addEventListener('input', (e) => {
            searchQuery = e.target.value;
            filterMeetings();
        });
        
        
        // File drop handling
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('active');
        });
        
        document.addEventListener('dragleave', (e) => {
            if (!e.relatedTarget) {
                dropZone.classList.remove('active');
            }
        });
        
        document.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('active');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type.startsWith('audio/') || file.name.match(/\.(wav|mp3|m4a|aac)$/i)) {
                    log(`Processing dropped file: ${file.name}`);
                    setStatus('processing', 'Processing file...');
                    
                    try {
                        const sessionName = file.name.replace(/\.[^/.]+$/, ''); // Remove extension
                        processingMeetings.add(sessionName);
                        renderMeetingsList(); // Update UI to show processing state
                        const result = await ipcRenderer.invoke('process-recording', file.path, sessionName);
                        
                        if (result.success) {
                            log('File processed successfully');
                            setStatus('ready', 'Complete');
                            processingMeetings.delete(sessionName);
                            
                            // Force refresh meetings list after processing
                            setTimeout(() => {
                                loadMeetings(true);
                            }, 1000);
                        } else {
                            log(`Processing failed: ${result.error}`);
                            setStatus('ready', 'Processing failed');
                            processingMeetings.delete(sessionName);
                            renderMeetingsList();
                        }
                    } catch (error) {
                        log(`Processing error: ${error.message}`);
                        setStatus('ready', 'Error');
                        processingMeetings.delete(sessionName);
                        renderMeetingsList();
                    }
                } else {
                    log('Invalid file type. Please drop an audio file.');
                }
            }
        });
        
        // Check initial recording status once
        async function checkInitialStatus() {
            try {
                const result = await ipcRenderer.invoke('get-status');
                if (result.success && result.status.includes('RECORDING')) {
                    log('Found active recording session - syncing UI state');
                    setUIState('recording');
                    startStatusMonitoring();
                } else {
                    setUIState('ready');
                }
            } catch (error) {
                log(`Failed to check initial status: ${error.message}`);
                setUIState('ready');
            }
        }

        // Auto-clear state on startup
        async function initializeApp() {
            // Clear debug logs for fresh start
            clearDebugLog();
            
            log('Initializing Steno Recorder...');
            
            // Request notification permission early (non-blocking)
            if (Notification.permission === 'default') {
                Notification.requestPermission().catch(() => {}); // Don't wait for this
            }
            
            // Parallel startup: Load meetings first (user sees content immediately),
            // then clear state and check status in background
            const startTime = Date.now();
            
            try {
                // Start loading meetings immediately (most important for user experience)
                const meetingsPromise = loadMeetings();
                
                // Do maintenance tasks in parallel
                const maintenancePromise = Promise.all([
                    ipcRenderer.invoke('clear-state').catch(err => 
                        log(`State clear failed: ${err.message}`)
                    ),
                    checkInitialStatus().catch(err => 
                        log(`Status check failed: ${err.message}`)
                    )
                ]);
                
                // Wait for meetings to load (priority), maintenance can finish in background
                await meetingsPromise;
                log(`Meetings loaded (${Date.now() - startTime}ms)`);
                
                // Wait for maintenance to complete
                await maintenancePromise;
                
            } catch (error) {
                log(`Initialization error: ${error.message}`);
                // Continue anyway - app should still be usable
            }
            
            log(`Steno Recorder ready (${Date.now() - startTime}ms total)`);
        }

        // Startup setup flow
        let setupInProgress = false;
        
        setupAutoStart.addEventListener('click', async () => {
            if (setupInProgress) return;
            await runSetupProcess();
        });
        
        setupContinue.addEventListener('click', () => {
            setupOverlay.style.display = 'none';
            // Refresh meetings after setup completion to ensure fresh data
            loadMeetings(true);
        });
        
        // Settings button click handler
        settingsBtn.addEventListener('click', () => {
            toggleSettings();
        });

        // Debug button click handler
        debugBtn.addEventListener('click', () => {
            toggleDebug();
        });

        // AI Settings button click handler
        aiSettingsBtn.addEventListener('click', () => {
            toggleAISettings();
        });
        
        // Reprocess button click handler
        reprocessBtn.addEventListener('click', async () => {
            if (!selectedMeeting) return;
            
            const summaryFile = selectedMeeting.session_info?.summary_file;
            if (!summaryFile) {
                log('‚ùå No summary file found for reprocessing');
                return;
            }
            
            // Track which meeting is being processed
            processingMeeting = selectedMeeting;
            
            // Show processing state
            reprocessBtn.disabled = true;
            reprocessBtn.classList.add('processing');
            reprocessBtn.innerHTML = '<div class="reprocess-spinner"></div>Processing...';
            
            const meetingBeingProcessed = selectedMeeting; // Capture the meeting being processed
            log(`üîÑ Reprocessing meeting: ${meetingBeingProcessed.session_info?.name}`);
            
            try {
                // Call main process to reprocess the meeting
                const result = await ipcRenderer.invoke('reprocess-meeting', summaryFile);
                
                if (result.success) {
                    log('‚úÖ Meeting reprocessed successfully');
                    
                    // Send notification for reprocessing completion
                    showDesktopNotification('StenoAI - Reprocessing Complete', {
                        body: `"${meetingBeingProcessed.session_info?.name || 'Meeting'}" has been reanalyzed`,
                        requireInteraction: false
                    });
                    
                    // Reload meetings to show updated data
                    await loadMeetings(true);
                    // Re-select the current meeting to show updated content
                    const updatedMeetingIndex = filteredMeetings.findIndex(m => 
                        m.session_info?.summary_file === summaryFile
                    );
                    if (updatedMeetingIndex !== -1) {
                        selectMeeting(updatedMeetingIndex);
                    }
                } else {
                    log(`‚ùå Reprocessing failed: ${result.error}`);
                }
            } catch (error) {
                log(`‚ùå Reprocessing error: ${error.message}`);
            } finally {
                // Clear processing tracker
                processingMeeting = null;
                
                // Reset button state only if we're still viewing the same meeting
                if (selectedMeeting && selectedMeeting.session_info?.summary_file === summaryFile) {
                    reprocessBtn.disabled = false;
                    reprocessBtn.classList.remove('processing');
                    reprocessBtn.innerHTML = 'Reprocess';
                }
            }
        });
        
        // Copy transcript to clipboard
        copyTranscriptBtn.addEventListener('click', async () => {
            try {
                const transcriptText = detailTranscript.textContent || '';
                if (!transcriptText || transcriptText === 'No transcript available') {
                    log('‚ùå No transcript available to copy');
                    return;
                }
                
                await navigator.clipboard.writeText(transcriptText);
                
                // Visual feedback
                copyTranscriptBtn.classList.add('copied');
                copyTranscriptBtn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20,6 9,17 4,12"></polyline>
                    </svg>
                `;
                
                // Reset after 2 seconds
                setTimeout(() => {
                    copyTranscriptBtn.classList.remove('copied');
                    copyTranscriptBtn.innerHTML = `
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                    `;
                }, 2000);
                
                log('üìã Transcript copied to clipboard');
            } catch (error) {
                log(`‚ùå Failed to copy transcript: ${error.message}`);
            }
        });

        // Copy all meeting notes to clipboard
        copyNotesBtn.addEventListener('click', async () => {
            try {
                if (!selectedMeeting) {
                    log('‚ùå No meeting selected to copy');
                    return;
                }

                // Format meeting notes as text
                const meetingName = selectedMeeting.session_info?.name || 'Untitled Meeting';
                const date = formatDate(selectedMeeting.session_info?.processed_at);
                const duration = selectedMeeting.session_info?.duration_seconds ?
                    `${Math.floor(selectedMeeting.session_info.duration_seconds / 60)}m ${selectedMeeting.session_info.duration_seconds % 60}s` :
                    'Unknown';

                let notesText = `${meetingName}\n`;
                notesText += `Date: ${date}\n`;
                notesText += `Duration: ${duration}\n`;
                notesText += `\n`;

                // Summary
                if (selectedMeeting.summary) {
                    notesText += `SUMMARY\n`;
                    notesText += `${selectedMeeting.summary}\n\n`;
                }

                // Participants
                if (selectedMeeting.participants && selectedMeeting.participants.length > 0) {
                    notesText += `PARTICIPANTS\n`;
                    selectedMeeting.participants.forEach(participant => {
                        notesText += `- ${participant}\n`;
                    });
                    notesText += `\n`;
                }

                // Key Topics (Discussion Areas)
                if (selectedMeeting.discussion_areas && selectedMeeting.discussion_areas.length > 0) {
                    notesText += `KEY TOPICS\n`;
                    selectedMeeting.discussion_areas.forEach(area => {
                        notesText += `\n${area.title}\n`;
                        notesText += `${area.analysis}\n`;
                    });
                    notesText += `\n`;
                }

                // Key Points
                if (selectedMeeting.key_points && selectedMeeting.key_points.length > 0) {
                    notesText += `KEY POINTS\n`;
                    selectedMeeting.key_points.forEach(point => {
                        notesText += `- ${point}\n`;
                    });
                    notesText += `\n`;
                }

                // Action Items
                if (selectedMeeting.action_items && selectedMeeting.action_items.length > 0) {
                    notesText += `ACTION ITEMS\n`;
                    selectedMeeting.action_items.forEach(item => {
                        notesText += `- ${item}\n`;
                    });
                }

                await navigator.clipboard.writeText(notesText);

                // Visual feedback
                copyNotesBtn.classList.add('copied');
                const originalHTML = copyNotesBtn.innerHTML;
                copyNotesBtn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20,6 9,17 4,12"></polyline>
                    </svg>
                    Copied!
                `;

                // Reset after 2 seconds
                setTimeout(() => {
                    copyNotesBtn.classList.remove('copied');
                    copyNotesBtn.innerHTML = originalHTML;
                }, 2000);

                log('üìã Meeting notes copied to clipboard');
            } catch (error) {
                log(`‚ùå Failed to copy notes: ${error.message}`);
            }
        });

        // Edit meeting title - define as a reusable function
        function startEditingTitle() {
            if (!selectedMeeting) return;

            const titleElement = document.getElementById('detail-title');
            const editBtn = document.getElementById('edit-title-btn');
            const currentTitle = titleElement.textContent;

            // Hide title and edit button
            titleElement.style.display = 'none';
            editBtn.style.display = 'none';

            // Create input and buttons
            const titleContainer = document.querySelector('.meeting-title-container');
            const inputHTML = `
                <input type="text" class="meeting-title-input" id="title-input" value="${currentTitle}">
                <div class="title-edit-actions">
                    <button class="save-title-btn" id="save-title-btn">Save</button>
                    <button class="cancel-title-btn" id="cancel-title-btn">Cancel</button>
                </div>
            `;
            titleContainer.insertAdjacentHTML('beforeend', inputHTML);

            const titleInput = document.getElementById('title-input');
            const saveTitleBtn = document.getElementById('save-title-btn');
            const cancelTitleBtn = document.getElementById('cancel-title-btn');

            // Focus and select the input
            titleInput.focus();
            titleInput.select();

            // Save on Enter key
            titleInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveTitleBtn.click();
                } else if (e.key === 'Escape') {
                    cancelTitleBtn.click();
                }
            });

            // Cancel function
            const cancelEdit = () => {
                titleInput.remove();
                document.querySelector('.title-edit-actions').remove();
                titleElement.style.display = '';
                editBtn.style.display = '';
            };

            // Save function
            const saveTitle = async () => {
                const newTitle = titleInput.value.trim();
                if (!newTitle || newTitle === currentTitle) {
                    cancelEdit();
                    return;
                }

                try {
                    const result = await ipcRenderer.invoke('update-meeting',
                        selectedMeeting.session_info.summary_file,
                        { name: newTitle }
                    );

                    if (result.success) {
                        // Update local data
                        selectedMeeting.session_info.name = newTitle;

                        // Update the SAME title element (keeps detailTitle reference valid)
                        titleElement.textContent = newTitle;

                        // Remove input and show title again
                        titleInput.remove();
                        document.querySelector('.title-edit-actions').remove();
                        titleElement.style.display = '';
                        editBtn.style.display = '';

                        // Reload meetings list to show updated name
                        await loadMeetings(true);

                        log(`‚úèÔ∏è Meeting name updated to: ${newTitle}`);
                    } else {
                        log(`‚ùå Failed to update meeting name: ${result.error}`);
                        cancelEdit();
                    }
                } catch (error) {
                    log(`‚ùå Error updating meeting name: ${error.message}`);
                    cancelEdit();
                }
            };

            cancelTitleBtn.addEventListener('click', cancelEdit);
            saveTitleBtn.addEventListener('click', saveTitle);
        }

        // Attach the initial event listener
        editTitleBtn.addEventListener('click', startEditingTitle);

        // Listen for debug messages from backend
        ipcRenderer.on('debug-log', (event, message) => {
            debugLog(message);
        });

        // Listen for global hotkey toggle recording
        ipcRenderer.on('toggle-recording-hotkey', () => {
            log('Global hotkey received: toggle recording');
            if (uiState === 'recording') {
                // Stop recording
                stopBtn.click();
            } else if (uiState === 'ready') {
                // Start recording
                startBtn.click();
            }
            // Ignore if in 'processing' state
        });
        
        async function runSetupProcess() {
            setupInProgress = true;
            setupAutoStart.style.display = 'none';
            
            // Clear and initialize debug console
            const debugConsole = document.getElementById('debug-console');
            debugConsole.textContent = 'StenoAI Setup Debug Console - Setup Started\n';
            debugLog('='.repeat(50));
            debugLog('Starting First-Time Setup Process');
            debugLog('='.repeat(50));
            
            const steps = [
                { id: 'step-microphone', handler: 'request-microphone-permission', name: 'Microphone Access' },
                { id: 'step-system', handler: 'setup-system-check', name: 'System Check' },
                { id: 'step-python', handler: 'setup-python', name: 'Python Dependencies' },
                { id: 'step-whisper', handler: 'setup-whisper', name: 'Whisper Installation' },
                { id: 'step-ollama', handler: 'setup-ollama-and-model', name: 'Ollama + AI Model' },
                { id: 'step-ffmpeg', handler: 'setup-ffmpeg', name: 'ffmpeg Installation' },
                { id: 'step-test', handler: 'setup-test', name: 'System Test' }
            ];
            
            for (const step of steps) {
                const element = document.getElementById(step.id);
                const statusElement = document.getElementById(step.id.replace('step-', '') + '-status');
                
                // Mark as active
                element.classList.remove('completed', 'failed');
                element.classList.add('active');
                statusElement.textContent = 'Running...';
                
                // Log to debug console
                debugLog(`\n>>> Starting: ${step.name}`);
                debugLog(`Command: ${step.handler}`);

                try {
                    const result = await ipcRenderer.invoke(step.handler);

                    if (result.success) {
                        element.classList.remove('active');
                        element.classList.add('completed');
                        statusElement.textContent = result.message || 'Completed';
                        debugLog(`‚úÖ SUCCESS: ${result.message || 'Completed'}`);

                        // Special handling for microphone permission completion
                        if (step.id === 'step-microphone') {
                            statusElement.textContent = 'Permission granted!';
                            debugLog('Microphone permission granted - can proceed with other setup steps');
                        }
                        
                    } else {
                        element.classList.remove('active');
                        element.classList.add('failed');
                        statusElement.textContent = result.error || 'Failed';
                        
                        debugLog(`‚ùå FAILED: ${result.error || 'Failed'}`);
                        
                        // Show detailed error in debug console if available
                        if (result.details) {
                            debugLog('--- Error Details ---');
                            debugLog(result.details);
                            debugLog('--- End Error Details ---');
                        }
                        
                        // Show retry button on failure
                        setupAutoStart.textContent = 'Retry Setup';
                        setupAutoStart.style.display = 'block';
                        setupInProgress = false;
                        return;
                    }
                } catch (error) {
                    element.classList.remove('active');
                    element.classList.add('failed');
                    statusElement.textContent = 'Failed';
                    
                    debugLog(`‚ùå EXCEPTION: ${error.message}`);
                    debugLog(`Stack trace: ${error.stack}`);
                    
                    // Show retry button on failure
                    setupAutoStart.textContent = 'Retry Setup';
                    setupAutoStart.style.display = 'block';
                    setupInProgress = false;
                    return;
                }
                
                // Small delay between steps
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            log('üéâ Setup completed successfully!');
            debugLog('\n' + '='.repeat(50));
            debugLog('üéâ Setup completed successfully!');
            debugLog('All components installed and tested.');
            debugLog('='.repeat(50));
            
            setupContinue.style.display = 'block';
            setupInProgress = false;
        }
        
        // Smooth startup with automatic setup detection
        async function runStartupCheck() {
            log('üîç Checking system setup...');
            
            try {
                // Check microphone permission and system setup together
                const micResult = await ipcRenderer.invoke('check-microphone-permission');
                const micGranted = micResult.success && micResult.status === 'granted';
                
                const result = await ipcRenderer.invoke('startup-setup-check');
                const systemReady = result.success && result.allGood;
                
                if (micGranted && systemReady) {
                    // Everything is ready - continue to main app
                    log('System ready!');
                    return;
                } else {
                    // Show unified setup wizard (includes microphone + system setup)
                    log('‚öôÔ∏è Setup needed - showing unified setup wizard');
                    showSetupOverlay(result.checks || []);
                }
            } catch (error) {
                log(`Setup check failed: ${error.message}`);
                // Show setup overlay as fallback
                log('üÜï First time setup detected');
                showSetupOverlay([]);
            }
        }
        
        async function showSetupOverlay(checks) {
            setupOverlay.style.display = 'flex';
            
            // Show ALL steps and reset their state
            document.querySelectorAll('.setup-step').forEach(step => {
                step.style.display = 'flex'; // Make sure all steps are visible
                step.classList.remove('active', 'completed', 'failed');
            });
            
            // Check and update microphone permission status
            try {
                const micResult = await ipcRenderer.invoke('check-microphone-permission');
                const micStep = document.getElementById('step-microphone');
                const micStatus = document.getElementById('microphone-status');
                
                if (micResult.success && micResult.status === 'granted') {
                    micStep.classList.add('completed');
                    micStatus.textContent = 'Permission granted';
                } else {
                    micStep.classList.add('failed');
                    micStatus.textContent = 'Requesting microphone permission...';
                    
                    // Automatically request microphone permission if missing
                    log('üé§ Microphone permission missing - automatically requesting...');
                    setTimeout(async () => {
                        try {
                            const requestResult = await ipcRenderer.invoke('request-microphone-permission');
                            if (requestResult.success && requestResult.granted) {
                                micStep.classList.remove('failed');
                                micStep.classList.add('completed');
                                micStatus.textContent = 'Permission granted!';
                                log('‚úÖ Microphone permission granted automatically');
                            } else {
                                micStatus.textContent = 'Permission denied - please grant in System Preferences';
                                log('‚ùå Microphone permission denied by user');
                            }
                        } catch (error) {
                            micStatus.textContent = 'Failed to request permission';
                            log(`‚ùå Error requesting microphone permission: ${error.message}`);
                        }
                    }, 1000); // Small delay to show the status message
                }
            } catch (error) {
                console.error('Failed to check microphone permission:', error);
            }
            
            // Update other step statuses based on backend check
            checks.forEach(check => {
                const [status, detail] = check;
                updateStepStatus(status, detail);
            });
            
            // Show appropriate button
            const hasFailures = checks.length === 0 || checks.some(([status]) => status.startsWith('‚ùå'));
            if (hasFailures || checks.length === 0) {
                setupAutoStart.style.display = 'block';
                setupAutoStart.textContent = checks.length === 0 ? 'Begin First-Time Setup' : 'Install Missing Dependencies';
                setupContinue.style.display = 'none';
            } else {
                setupContinue.style.display = 'block';
                setupAutoStart.style.display = 'none';
            }
        }
        
        function updateStepStatus(status, detail) {
            // Map backend check results to UI steps - only show setup for missing installations
            if (status.includes('Python')) {
                updateStep('step-system', status.startsWith('‚úÖ') ? 'completed' : 'failed', detail);
            } else if (status.includes('sounddevice')) {
                updateStep('step-python', status.startsWith('‚úÖ') ? 'completed' : 'failed', detail);
            } else if (status.includes('whisper')) {
                updateStep('step-whisper', status.startsWith('‚úÖ') ? 'completed' : 'failed', detail);
            } else if (status.includes('Ollama') || status.includes('Llama')) {
                // Only show as failed if actually missing, not just service down
                if (detail.includes('not installed') || detail.includes('missing')) {
                    updateStep('step-ollama', status.startsWith('‚úÖ') ? 'completed' : 'failed', detail);
                } else if (status.startsWith('‚úÖ')) {
                    updateStep('step-ollama', 'completed', detail);
                }
            }
        }
        
        function updateStep(stepId, state, message) {
            const element = document.getElementById(stepId);
            const statusElement = document.getElementById(stepId.replace('step-', '') + '-status');
            
            element.classList.remove('active', 'completed', 'failed');
            element.classList.add(state);
            statusElement.textContent = message;
        }

        // Listen for automatic meetings refresh from backend (legacy - kept for compatibility)
        ipcRenderer.on('meetings-refreshed', (event, meetingsData) => {
            log('Processing complete! Meeting list automatically refreshed');
            meetings = meetingsData || [];
            filterMeetings(); // Apply current search filter and render
        });
        
        // Listen for model pull progress
        ipcRenderer.on('model-pull-progress', (event, data) => {
            updateModelProgress(data.model, data.progress);
        });

        // Listen for model pull completion
        ipcRenderer.on('model-pull-complete', (event, data) => {
            hideModelDownloading(data.model);

            if (data.success) {
                showModelNotification(`Successfully downloaded ${data.model}!`, 'success');
                loadModels(); // Reload to show as installed
            } else {
                showModelNotification(`Failed to download ${data.model}: ${data.error}`, 'error');
            }
        });

        // Listen for processing completion events
        ipcRenderer.on('processing-complete', (event, data) => {
            log(`Processing complete for: ${data.sessionName}`);
            processingMeetings.delete(data.sessionName);
            
            if (data.success) {
                if (data.meetingData) {
                    // Update the specific meeting with processed data
                    const tempMeetingIndex = meetings.findIndex(meeting => 
                        meeting.session_info?.name === data.sessionName && meeting.summary === 'Pending...'
                    );
                    
                    if (tempMeetingIndex !== -1) {
                        // Replace temporary meeting with processed data
                        meetings[tempMeetingIndex] = data.meetingData;
                        meetingsLastLoaded = Date.now(); // Update cache timestamp
                    } else {
                        // Add new meeting if temp entry not found
                        meetings.unshift(data.meetingData);
                        meetingsLastLoaded = Date.now(); // Update cache timestamp
                    }
                    
                    // Re-render the meetings list with updated data
                    filterMeetings();
                } else {
                    // No meetingData provided - force refresh from backend
                    log('No meeting data in completion event - forcing refresh');
                    loadMeetings(true);
                }
                
                // Show native notification
                showDesktopNotification('StenoAI - Meeting Notes Ready', {
                    body: `"${data.sessionName}" has been transcribed and summarized`,
                    requireInteraction: false
                });
                
                setStatus('ready', 'Processing complete');
            } else {
                // Remove temporary meeting entry on failure
                meetings = meetings.filter(meeting => 
                    !(meeting.session_info?.name === data.sessionName && meeting.summary === 'Pending...')
                );
                
                setStatus('ready', 'Processing failed');
                log(`Processing failed: ${data.error}`);
                filterMeetings();
            }
        });
        
        // Settings panel functionality
        let settingsVisible = false;

        function toggleSettings() {
            const settingsPanel = document.getElementById('settings-panel');
            settingsVisible = !settingsVisible;

            if (settingsVisible) {
                settingsPanel.style.right = '0';
                loadNotificationSettings();
            } else {
                settingsPanel.style.right = '-400px';
            }
        }

        let debugVisible = false;

        function toggleDebug() {
            const debugPanel = document.getElementById('debug-panel');
            debugVisible = !debugVisible;

            if (debugVisible) {
                debugPanel.style.right = '0';
            } else {
                debugPanel.style.right = '-500px';
            }
        }

        let aiSettingsVisible = false;

        function toggleAISettings() {
            const aiSettingsPanel = document.getElementById('ai-settings-panel');
            aiSettingsVisible = !aiSettingsVisible;

            if (aiSettingsVisible) {
                aiSettingsPanel.style.right = '0';
                loadPrompts();
                loadModels();
            } else {
                aiSettingsPanel.style.right = '-400px';
            }
        }
        
        async function loadPrompts() {
            try {
                const prompts = await ipcRenderer.invoke('get-ai-prompts');
                const promptElement = document.getElementById('summarization-prompt');
                
                if (prompts.success) {
                    promptElement.textContent = prompts.summarization || 'Prompt not available';
                } else {
                    promptElement.textContent = 'Failed to load prompts';
                }
            } catch (error) {
                document.getElementById('summarization-prompt').textContent = 'Failed to load prompts';
            }
            
            // Load app version
            try {
                const versionInfo = await ipcRenderer.invoke('get-app-version');
                const versionElement = document.getElementById('app-version');
                
                if (versionInfo.success) {
                    versionElement.textContent = `v${versionInfo.version}`;
                } else {
                    versionElement.textContent = 'Unknown';
                }
            } catch (error) {
                document.getElementById('app-version').textContent = 'Unknown';
            }
        }

        // Model management functions
        async function loadModels() {
            try {
                const result = await ipcRenderer.invoke('list-models');

                if (result.success) {
                    displayCurrentModel(result.current_model);
                    displayModelList(result.supported_models, result.current_model);
                } else {
                    document.getElementById('current-model-display').innerHTML = '<span style="color: #f44336;">Failed to load models</span>';
                    document.getElementById('model-list').innerHTML = '<span style="color: #f44336;">Failed to load model list</span>';
                }
            } catch (error) {
                console.error('Error loading models:', error);
                document.getElementById('current-model-display').innerHTML = '<span style="color: #f44336;">Error loading models</span>';
                document.getElementById('model-list').innerHTML = '<span style="color: #f44336;">Error loading model list</span>';
            }
        }

        function displayCurrentModel(modelName) {
            const currentModelDisplay = document.getElementById('current-model-display');
            currentModelDisplay.innerHTML = `<span style="font-family: Monaco, monospace; color: #4CAF50;">${modelName}</span>`;
        }

        function displayModelList(models, currentModel) {
            const modelListDiv = document.getElementById('model-list');
            modelListDiv.innerHTML = '';

            for (const [modelName, modelInfo] of Object.entries(models)) {
                const isCurrentModel = modelName === currentModel;

                const modelCard = document.createElement('div');
                modelCard.style.cssText = `
                    padding: 12px;
                    background: ${isCurrentModel ? '#2a4a2a' : '#2a2a2a'};
                    border: 2px solid ${isCurrentModel ? '#4CAF50' : '#444'};
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.2s;
                `;

                modelCard.setAttribute('data-model-name', modelName);
                modelCard.setAttribute('data-model-size', modelInfo.size);

                // Extract tag from description (e.g., "(default)")
                const tagMatch = modelInfo.description.match(/\((default|recommended)\)/i);
                const tag = tagMatch ? ` ${tagMatch[0]}` : '';

                modelCard.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 4px; font-family: Monaco, monospace;">
                                ${modelName}${tag}
                                ${isCurrentModel ? '<span style="color: #4CAF50; margin-left: 8px;">‚úì Active</span>' : ''}
                            </div>
                            <div style="font-size: 12px; color: #aaa;">
                                Size: ${modelInfo.size} | Speed: ${modelInfo.speed} | Quality: ${modelInfo.quality}
                            </div>
                            <div class="model-progress" style="display: none; margin-top: 8px; padding: 8px; background: #1a1a1a; border-radius: 4px;">
                                <div class="progress-text" style="font-size: 11px; color: #4CAF50; font-family: Monaco, monospace;">Downloading...</div>
                            </div>
                        </div>
                        <div style="margin-left: 15px;">
                            ${isCurrentModel ?
                                '<span style="color: #4CAF50; font-size: 24px;">‚óè</span>' :
                                '<button class="btn" onclick="selectModel(\'' + modelName + '\')" style="margin: 0; padding: 6px 12px; font-size: 12px;">Select</button>'
                            }
                        </div>
                    </div>
                `;

                if (!isCurrentModel) {
                    modelCard.onmouseenter = () => {
                        modelCard.style.borderColor = '#4CAF50';
                        modelCard.style.background = '#2a3a2a';
                    };
                    modelCard.onmouseleave = () => {
                        modelCard.style.borderColor = '#444';
                        modelCard.style.background = '#2a2a2a';
                    };
                }

                modelListDiv.appendChild(modelCard);
            }
        }

        async function selectModel(modelName) {
            try {
                // Check if model is already installed
                const checkResult = await ipcRenderer.invoke('check-model-installed', modelName);

                if (!checkResult.success) {
                    alert(`Error checking model status: ${checkResult.error}`);
                    return;
                }

                const isInstalled = checkResult.installed;
                let confirmMsg;

                if (isInstalled) {
                    confirmMsg = `Switch to model: ${modelName}?\n\nThis model is already installed and ready to use.`;
                } else {
                    confirmMsg = `Switch to model: ${modelName}?\n\nThis model will be downloaded (${getModelSize(modelName)}).\n\n‚ö†Ô∏è WARNING: Model downloads will pause any active summarization.\nWait for current processing to finish before downloading.`;
                }

                if (!confirm(confirmMsg)) {
                    return;
                }

                // Set the model preference
                const result = await ipcRenderer.invoke('set-model', modelName);

                if (!result.success) {
                    alert(`Failed to set model: ${result.error}`);
                    return;
                }

                // If already installed, just reload and show success
                if (isInstalled) {
                    showModelNotification(`Switched to ${modelName}!`, 'success');
                    loadModels();
                    return;
                }

                // Model needs to be downloaded - start non-blocking pull
                showModelDownloading(modelName);

                // Start download (non-blocking - returns immediately)
                ipcRenderer.invoke('pull-model', modelName).catch(error => {
                    console.error('Error starting model pull:', error);
                    hideModelDownloading(modelName);
                    showModelNotification(`Failed to start download: ${error.message}`, 'error');
                });

            } catch (error) {
                console.error('Error selecting model:', error);
                alert(`Error selecting model: ${error.message}`);
            }
        }

        function getModelSize(modelName) {
            const modelList = document.getElementById('model-list');
            const modelCards = modelList.querySelectorAll('[data-model-name]');
            for (const card of modelCards) {
                if (card.dataset.modelName === modelName) {
                    const sizeText = card.dataset.modelSize;
                    return sizeText || 'unknown size';
                }
            }
            return 'unknown size';
        }

        function showModelDownloading(modelName) {
            const modelCard = document.querySelector(`[data-model-name="${modelName}"]`);
            if (!modelCard) return;

            const progressDiv = modelCard.querySelector('.model-progress');
            if (progressDiv) {
                progressDiv.style.display = 'block';
                progressDiv.querySelector('.progress-text').textContent = 'Starting download...';
            }
        }

        function hideModelDownloading(modelName) {
            const modelCard = document.querySelector(`[data-model-name="${modelName}"]`);
            if (!modelCard) return;

            const progressDiv = modelCard.querySelector('.model-progress');
            if (progressDiv) {
                progressDiv.style.display = 'none';
            }
        }

        function updateModelProgress(modelName, progressText) {
            const modelCard = document.querySelector(`[data-model-name="${modelName}"]`);
            if (!modelCard) return;

            const progressDiv = modelCard.querySelector('.model-progress');
            if (progressDiv) {
                progressDiv.querySelector('.progress-text').textContent = progressText;
            }
        }

        function showModelNotification(message, type = 'info') {
            // In-app notification toast (bottom-right, matches app theme)
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                padding: 15px 20px;
                background: ${type === 'success' ? '#22c55e' : type === 'error' ? '#ef4444' : '#3b82f6'};
                color: white;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.5);
                z-index: 10000;
                font-size: 14px;
                max-width: 350px;
                animation: slideInFromBottom 0.3s ease-out;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            const duration = type === 'error' ? 5000 : 3000;
            setTimeout(() => {
                notification.style.animation = 'slideOutToBottom 0.3s ease-in';
                setTimeout(() => notification.remove(), 300);
            }, duration);
        }

        async function loadNotificationSettings() {
            try {
                const result = await ipcRenderer.invoke('get-notifications');
                const toggle = document.getElementById('notifications-toggle');

                if (result.success) {
                    toggle.checked = result.notifications_enabled;
                } else {
                    console.error('Failed to load notification settings:', result.error);
                    toggle.checked = true; // Default to enabled
                }
            } catch (error) {
                console.error('Error loading notification settings:', error);
                document.getElementById('notifications-toggle').checked = true;
            }
        }

        async function showDesktopNotification(title, options) {
            // Check if desktop notifications are enabled in settings
            try {
                const result = await ipcRenderer.invoke('get-notifications');
                const notificationsEnabled = result.success ? result.notifications_enabled : true;

                if (Notification.permission === 'granted' && notificationsEnabled) {
                    new Notification(title, options);
                }
            } catch (error) {
                console.error('Error checking notification settings:', error);
                // Default to showing if error
                if (Notification.permission === 'granted') {
                    new Notification(title, options);
                }
            }
        }

        // Setup notification toggle event listener
        document.addEventListener('DOMContentLoaded', () => {
            const notificationsToggle = document.getElementById('notifications-toggle');
            if (notificationsToggle) {
                notificationsToggle.addEventListener('change', async (e) => {
                    try {
                        const enabled = e.target.checked;
                        const result = await ipcRenderer.invoke('set-notifications', enabled);

                        if (result.success) {
                            showModelNotification(
                                `Desktop notifications ${enabled ? 'enabled' : 'disabled'}`,
                                'success'
                            );
                        } else {
                            console.error('Failed to save notification setting:', result.error);
                            showModelNotification('Failed to save setting', 'error');
                            // Revert toggle
                            e.target.checked = !enabled;
                        }
                    } catch (error) {
                        console.error('Error saving notification setting:', error);
                        showModelNotification('Failed to save setting', 'error');
                        e.target.checked = !e.target.checked;
                    }
                });
            }
        });

        async function runSetupFromSettings() {
            const btn = document.getElementById('run-setup-btn');
            btn.textContent = 'Running Setup...';
            btn.disabled = true;
            
            try {
                // Show setup overlay in main window
                document.getElementById('setup-overlay').style.display = 'flex';
                
                // Run the setup process
                await runSetupProcess();
                
                btn.textContent = 'Setup Complete!';
                setTimeout(() => {
                    btn.textContent = 'Run Setup Wizard';
                    btn.disabled = false;
                }, 3000);
            } catch (error) {
                console.error('Setup failed:', error);
                btn.textContent = 'Setup Failed - Try Again';
                btn.disabled = false;
            }
        }
        
        function toggleDebugConsole() {
            const console = document.getElementById('debug-console');
            if (console.style.display === 'none') {
                console.style.display = 'block';
            } else {
                console.style.display = 'none';
            }
        }
        
        function clearDebugLog() {
            // Clear both debug consoles
            const setupConsole = document.getElementById('debug-console');
            if (setupConsole) {
                setupConsole.textContent = 'StenoAI Setup Debug Console\nCommands and output will appear here...\n\n';
            }
            
            const debugPanel = document.getElementById('debug-console-panel');
            if (debugPanel) {
                debugPanel.textContent = 'StenoAI Debug Console\nSession started - ready for activity...\n\n';
            }
        }

        function debugLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            const formattedMessage = `[${timestamp}] ${message}\n`;
            
            // Log to setup wizard console if it exists (during setup)
            const setupConsole = document.getElementById('debug-console');
            if (setupConsole) {
                setupConsole.textContent += formattedMessage;
                setupConsole.scrollTop = setupConsole.scrollHeight;
            }
            
            // Always log to debug panel
            const debugPanel = document.getElementById('debug-console-panel');
            if (debugPanel) {
                debugPanel.textContent += formattedMessage;
                debugPanel.scrollTop = debugPanel.scrollHeight;
            }
        }
        
        
        async function clearSystemState() {
            const btn = document.getElementById('clear-state-btn');
            btn.textContent = 'Clearing...';
            btn.disabled = true;
            
            try {
                const result = await ipcRenderer.invoke('clear-state');
                if (result.success) {
                    btn.textContent = 'State Cleared!';
                    log('Manual state clear successful');
                } else {
                    btn.textContent = 'Clear Failed';
                    log('Manual state clear failed: ' + result.error);
                }
                
                setTimeout(() => {
                    btn.textContent = 'Clear Recording State';
                    btn.disabled = false;
                }, 2000);
            } catch (error) {
                console.error('Clear state failed:', error);
                btn.textContent = 'Clear Failed';
                btn.disabled = false;
                setTimeout(() => {
                    btn.textContent = 'Clear Recording State';
                }, 2000);
            }
        }
        
        async function testUpdateCheck() {
            const btn = document.getElementById('test-update-btn');
            btn.textContent = 'Checking...';
            btn.disabled = true;
            
            try {
                // Clear any previous dismissal to force showing banner
                sessionStorage.removeItem('updateDismissed');
                
                await checkForUpdates();
                
                btn.textContent = 'Check Complete!';
                setTimeout(() => {
                    btn.textContent = 'Test Update Check';
                    btn.disabled = false;
                }, 2000);
            } catch (error) {
                console.error('Update check test failed:', error);
                btn.textContent = 'Test Failed';
                btn.disabled = false;
                setTimeout(() => {
                    btn.textContent = 'Test Update Check';
                }, 2000);
            }
        }
        
        // Update checking functions
        async function checkForUpdates() {
            try {
                log('üîç Checking for updates...');
                const result = await ipcRenderer.invoke('check-for-updates');
                
                if (result.success) {
                    updateInfo = result;
                    log(`Update check: Current ${result.currentVersion}, Latest ${result.latestVersion}`);
                    
                    if (result.updateAvailable) {
                        showUpdateBanner(result);
                    }
                } else {
                    log(`Update check failed: ${result.error}`);
                }
            } catch (error) {
                log(`Update check error: ${error.message}`);
            }
        }
        
        function showUpdateBanner(info) {
            updateVersion.textContent = `v${info.latestVersion}`;
            updateBanner.classList.add('show');
            document.querySelector('.header').classList.add('with-update-banner');
            
            log(`üöÄ Update available: v${info.latestVersion}`);
        }
        
        function hideUpdateBanner() {
            updateBanner.classList.remove('show');
            document.querySelector('.header').classList.remove('with-update-banner');
            
            // Remember dismissal for this session (could extend to localStorage for persistence)
            sessionStorage.setItem('updateDismissed', updateInfo?.latestVersion || '');
        }
        
        function startPeriodicUpdateCheck() {
            // Check for updates every 6 hours
            updateCheckInterval = setInterval(checkForUpdates, 6 * 60 * 60 * 1000);
        }
        
        function stopPeriodicUpdateCheck() {
            if (updateCheckInterval) {
                clearInterval(updateCheckInterval);
                updateCheckInterval = null;
            }
        }
        
        // Update button event listeners
        viewReleaseBtn.addEventListener('click', async () => {
            if (updateInfo && updateInfo.releaseUrl) {
                try {
                    await ipcRenderer.invoke('open-release-page', updateInfo.releaseUrl);
                    log('Opened release page in browser');
                } catch (error) {
                    log(`Failed to open release page: ${error.message}`);
                }
            }
        });
        
        downloadUpdateBtn.addEventListener('click', async () => {
            if (updateInfo && updateInfo.releaseUrl) {
                try {
                    // Open the releases page where user can download
                    await ipcRenderer.invoke('open-release-page', updateInfo.releaseUrl);
                    log('Opened download page in browser');
                    
                    // Hide banner after user clicks download
                    hideUpdateBanner();
                } catch (error) {
                    log(`Failed to open download page: ${error.message}`);
                }
            }
        });
        
        dismissUpdateBtn.addEventListener('click', () => {
            hideUpdateBanner();
            log('Update notification dismissed');
        });

        // Initialize
        initializeApp().then(() => {
            runStartupCheck().then(() => {
                // Check for updates after app initialization
                setTimeout(() => {
                    // Only check if not dismissed this session
                    const dismissed = sessionStorage.getItem('updateDismissed');
                    if (!dismissed) {
                        checkForUpdates();
                    }
                }, 2000); // Wait 2 seconds after startup
                
                // Start periodic checks
                startPeriodicUpdateCheck();
            });
        });
    </script>
</body>
</html>
